<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node etc.</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Node etc.</h1>
    <p>Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on a JavaScript
        Engine (i.e. V8 engine) and executes JavaScript code outside a web browser, which was designed to build scalable
        network applications. Node.js lets developers use JavaScript to write command line tools and for server-side
        scripting—running scripts server-side to produce dynamic web page content before the page is sent to the user's
        web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application
        development around a single programming language, rather than different languages for server-side and
        client-side scripts.</p>
</body>
<h3>Running .js files using Node</h3>
<p>On the terminal:</p>
<pre><code>
    node firstScript.js
    <span class="red">the JS file will run inside the terminal</span>
</code></pre>
<h3>Process</h3>
<p>The process object is a global that provides information about, and control over, the current Node.js process. As a
    global, it is always available to Node.js applications without using require().</p>
<p>We can compare process to the window object on a browser.</p>
<h3>process.argv</h3>
<p>The process.argv property returns an array containing the command line arguments passed when the Node.js process was
    launched. The first element will be process.execPath. The process.execPath property returns the absolute pathname of
    the executable that started the Node.js process: usually '/usr/local/bin/node'. The second element will be the path
    to the JavaScript file being executed. The remaining elements will be any additional command line arguments.</p>
<pre><code>
    node firstScript.js puppies chickens hello
    <span class="red">these 3 strings will be added to the argv array.</span>
</code></pre>
<p>process.argv returns an array, and can be accessed from the js file.</p>

<h3>File System Module (fs)</h3>
<p>The fs module enables interacting with the file system. </p>
<p>All file system operations have synchronous, callback, and promise-based forms.</p>
<p>Unlike the process object, the fs module must be required before being used in the script.</p>
<p>Example: creating a script that creates boilerplates files (index.html, style.css, app.js) for a new project.</p>
<pre><code>
on script:
const fs = require('fs'); <span class="red">requires fs module</span>
const folderName = process.argv[2] || 'Project'; <span class="red">accesses the argument that was provided by the user</span>
fs.mkdirSync(folderName); <span class="red">creates a folder with the name provided by the user</span>
fs.writeFileSync(`${folderName}/index.html`, '');
fs.writeFileSync(`${folderName}/style.css`, '');
fs.writeFileSync(`${folderName}/app.js`, '')
<span class="red">creates these 3 files inside that folder. The second argument is the content of that file and can be set to empty.</span>

async version:
fs.mkdir(`${folderName}`, { recursive: true }, (err) => {
    console.log('The folder is successfully created')
    if (err) console.log(err);
 })
fs.writeFile(`${folderName}/index.html`, 'I am the new file\'s content', (err) => {
    console.log('The HTML file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/style.css`, 'I am the new file\'s content', (err) => {
    console.log('The CSS file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/app.js`, 'I am the new file\'s content', (err) => {
    console.log('The JS file is successfully created')
    if (err) console.log(err)
 });
 
on the command line:
node boilerplate.js Portfolio
<span class="red">creates a folder called Portfolio with those 3 files inside of it.</span>
</code></pre>

<h3>Exporting modules using module.export</h3>
<p>In order to create our own modules, the first thing to do is to put the value inside of module.exports object in the
    module's file.</p>
<p>Then we have to require the module using require('./moduleName') inside the file where we want to use it.</p>
<pre><code>
    on the module:
    module.exports.sum = (x,y) => x + y;
    exports.sum = (x,y) => x + y;
    <span class="red">exports is a shortcut for module.exports</span>

    on the script using the model:
    require('./math');
    <span class="red">assuming that the module's file is called math.js</span>
</code></pre>

<h3>Requiring a directory</h3>
<p>When requiring an entire folder, node.js will look into index.js, which should be inside that folder.</p>
<p>A common pattern is to require all values into index.js and then export them all from there.</p>

<h2>NPM</h2>
<p>NPM is the largest library of packages, which are modules written by other people, all ready for anyone to use.</p>
<p>NPM is also a command line tool to easily install and manage those packages in our Node projects.</p>

<h3>Installing packages from NPM</h3>
<p>To install a package from NPM, the basic command is: npm install packageName . This command has a shortcut: npm i
    packageName .</p>
<p>The correct packageName can be found in the package's documentation on NPM website.</p>
<p>To globally install a package, just add -g</p>
<pre><code>
    npm i packageName -g 
</code></pre>
<p>The global installation will install the package on the root of the computer, so that every project that requires
    that package will have it available. If the global installation fails, use this line to change permission:</p>
<pre><code>
sudo chown -R $USER/usr/local/lib/node_modules
</code></pre>

<h3>The <i>package.json</i> file</h3>
<p>Before installing any package to a projects folder, we have to run <b>npm init</b>. This will create a package.json
    file in the root of that project. This file contains metadata of the packages used by that project. Everytime we
    install a new package on that folder, this file will automatically update the <b>dependencies</b> property.</p>

<h3>Installing all dependencies for a project</h3>
<p>When uploading a project to GIThub, we don't need to upload the node_modules folder. All we have to do is to upload
    the <i>package.json</i> file. Then, the people who download the project code, will run the command line <i>npm
        install</i> in that folder, and that it! All the dependencies listed on the packages.json file will be
    automatically downloaded for that folder</p>


<h2>Express</h2>
<p>Express.js, or simply Express, is a back end web application framework for Node.js, released as free and open-source
    software under the MIT License. It is designed for building web applications and APIs.[3] It has been called the de
    facto standard server framework for Node.js.</p>

<h3>Starting a server</h3>
<pre><code>
    const express = require('express');
    const app = express();

app.use(() => {
    console.log('WE GOT A NEW REQUEST!');
    res.send('Hello, this is a response'); 
    <span class="red">the send method is what is sent as a response to the browser; it accepts strings, objects (which will be converted to json) and html.</span>
})
<span class="red">app.use is what happens when the request is received</span>

app.listen(8080, () => {
    console.log("LISTENING ON PORT 8080")
})
<span class="red">this sets the port on localhost where the requests are being listened; to access the server, go to localhost:8080 on any browser (on your machine)</span>
</code></pre>

<h3>Express routing basics</h3>
<p>Until now, it doesn't matter if the user is requesting the '/' page or the '/cats' page, with app.use the server will
    always send the same response.</p>
<p>Using app.get, we are able to get the exact request, and respond according to what comes after the /.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        res.send('This is the home page!');
    });

    app.get('/cats', (req, res) => {
        res.send('MEOW!');
    });

    app.get('/dogs', (req, res) => {
        res.send('WOOF!');
    });

    app.listen(8080, () => {
        console.log("LISTENING ON PORT 8080")
    })
</code></pre>
<p>Besides 'get', there are other http verbs, like, 'post', 'put', 'delete', etc. Express will differentiate incoming
    request of different types.</p>
<pre><code>
    app.post('/cats', (req, res) => {
        res.send('POST REQUEST TO /cats!!! This is a response!')
    })
</code></pre>
<p>To respond with a customized error page or message to a unexistent request address, (ex: '/hdhebdhbwh'):</p>
<pre><code>
    app.get('*', (req, res) => {
        res.send(`I don't know that path!`);
    });
</code></pre>

<h3>Routing path parameters</h3>
<p>In order to designate a pattern in a route, we can use :</p>
<pre><code>
    <span class="red">for ex, all Reddit's subreddits begin with the pattern /r/something</span>
    app.get('/r/:subreddit', (req, res) => {
        res.send('This is a subreddit!')
    })
</code></pre>
<p><b>req.params</b> is an object that contains one key/value pair for each routed pattern that we defined. The key of
    that property will be the word that we wrote after
    the colon(:), the value of that property will be the actual word requested by the user.</p>
<pre><code>
    app.get('/r/:subreddit', (req, res) => {
        { subredditName } = req.params;
        res.send(`< h2>Browsing the ${subredditName} subreddit!< /h2>`)
    })

    app.get('/r/:subreddit/:postId', (req, res) => {
        { subredditName, postId } = req.params;
        res.send(`< h1>Viewing the post called ${postId} on the ${subredditName} subreddit!< /h1>`)
    })
</code></pre>

<h3>Query strings</h3>
<p><b>req.query</b> is an object that contains one key/value pair for each query string requested by the user. The key
    of that property will be the name of the html form in which the query is generated, the value of that property will
    be the actual word requested by the user.</p>
<pre><code>
    app.get('search', (req, res) => {
        const { q } = req.query;
        res.send(`< h1>Search results for ${q}< /h1>`)
    });
</code></pre>

<h3>Auto-restart server with Nodemon</h3>
<p>Nodemon is a NPM package that automatically restarts the server every time we change our code on that project.
    Otherwise we have to restart the server so that the changes take place.</p>


<h3>Templating</h3>
<p>Templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify.</p>
<p>For example, we could define a single "Search" template that displays all the results for a given search term. We
    don't know what the term is or how many results there are ahead of time. The webpage id created on the fly.</p>
<p>There are many template languages to do this job, for example, EJS (embedded JS), Handlebars, Jade, Pug, Nunjucks
    etc.</p>

<h4>Setting EJS</h4>
<p>We need to "tell" Express that our template language will be EJS. Then we have to install EJS dependency on the
    project.</p>
<p>After installing EJS as a dependency, we don't have to require on the js script. When we set the 'view engine' to
    'ejs', Express will automatically do it for us.</p>
<p>We have to create a folder called 'views' inside the project directory, because EJS will look for this folder. Inside
    that folder, we need to create a file called 'something.ejs'.</p>
<p>We use res.render instead of res.send to render a ejs webpage inside the app.get callback. Express will automatically
    look for it in the /views folder.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.set('view engine', 'ejs');

    app.get('/'. (req, res) => {
        res.render('home.ejs')
        <span class="red">.ejs is optional</span>
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>
<p>In order to avoid conflicts, it is good practice to update the location of the '/views' folder using 'path.join'. The
    final code will look like this:</p>
<pre><code>
    const express = require('express');
    const app = express();
    const path = require('path');

    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, '/views'));

    app.get('/'. (req, res) => {
        res.render('home')
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>

<h4>EJS syntax</h4>
<b>Tags:</b>
<ul>
    <li>
        <% Scriptlet tag, for control-flow, no output</li>
    <li>
        <%_ Whitespace Slurping Scriptlet tag, strips all whitespace before it</li>
    <li>
        <%= Outputs the value into the template (HTML escaped). Escaped: turns HTML into string.</li>
    <li>
        <%- Outputs the unescaped value into the template. Unescaped: treats HTML just like HTML.</li>
    <li>
        <%# Comment tag, no execution, no output %>
    </li>
    <li>
        <%% Outputs a literal '<%' </li>
    <li>%> Plain ending tag</li>
    <li>-%> Trim-mode ('newline slurp') tag, trims following newline</li>
    <li>_%> ‘Whitespace Slurping’ ending tag, removes all whitespace after it
    </li>
</ul>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    res.render('random')
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> Your random number is: <%= Math.floor(Math.random() * 10) + 1 %>< /h1>
    < /body>
</code></pre>

<h4>Passing data to templates</h4>
<p>We usually don't run complex script on template views, instead what we can do is to run them in the js file, assign
    variables and call it in the ejs template view:</p>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    <b>const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand: num })</b>
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> <b> Your random number is: <%= rand %></b>< /h1>
    < /body>
</code></pre>

<h4>Conditionals in EJS</h4>
<p>The <% (without=) tag disposes logical code that won't be rendered. Following the random number script mentioned
        above:</p>
        <pre><code>
    <span class="red">on the template view (.ejs)</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        <% if(num%2 === 0){ %>
        < h2>That is an even number!< /h2>
        <% } else { %>
        < h2>That is an odd number!< /h2>  
        <% } %> 
    < /body>

    <span class="red">using ternary operator:</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        < h2> <%= num%2===0 ? 'That is an even number!' : 'That is an odd number!'  %>< /h2>  
    < /body>
</code></pre>

        <h4>Loops in EJS</h4>
        <pre><code>
    <span class="red">on index.js</span>
    app.get('/cats', (req, res) => {
        const cats = ['Blue', 'Rocket', 'Monty', 'Winston'];
        res.render('cats', { cats })
    })

    <span class="red">on cats.ejs</span>
    < body>
        < h1>All the cats< /h1>
        < ul>
            <% for(let cat of cats){ %>
            < li><%= cat %>< /li>
            <% } %>
        < /ul>
    < /body>
</code></pre>

<h4>Serving static files in Express</h4>
<p>To serve static files such as images, CSS files and JS files, use the <b>express.static</b> built-in middleware function in Express.</p>
<p>Com o Express, é possível entregar os arquivos estáticos de forma separada no sistema. E isso é importante porque você consegue dizer para o servidor, exatamente quais arquivos não precisam de um processamento, mas sim que ele só seja entregue para uso. Dessa forma o servidor vai entender que aquele arquivo, não requer nenhum tipo de lógica ou processamento para ser entregue, ele simplesmente é mostrado na tela para o usuário. Os arquivos estáticos podem ser fotos, arquivos, folhas de estilo css, arquivos javascript, arquivos somente com HTML e entre outros.</p>
<p>O express.static é um middleware que é integrado ao express e que permite indicar onde estarão os arquivos estáticos a serem carregados. É possível fazer a configuração somente uma vez, e normalmente é feita dentro do arquivo principal do sistema, que pode ser o server.js, main.js, index.js, depende de como configurou seu sistema. Essa configuração indica o diretório do servidor no qual estão os arquivos estáticos, com isso, sempre que no código tiver referência a uma imagem por exemplo, o servidor sabe que precisa ir buscar para o diretório que foi configurado.
Normalmente é configurado só um diretório e com o nome 'public'.</p>

<pre><code>
    app.use(express.static('/public'));

    <span class="red">using path.join to avoid conflicts</span>
    app.use(express.static(path.join(__dirname, '/public')));
</code></pre>

        <h4>EJS Partials</h4>
        <p>When we want a part of HTML (eg, an entire head) on all pages, we can save a .ejs file containing that code
            and then <b>include</b> the partial on every single page. It is a convention to create a folder for
            partials.</p>
        <pre><code>
<%- include('partials/head') %>
</code></pre>

        <h3>Defining RESTful Routes</h3>
        <p>A RESTful API is an architectural style for an application program interface (API) that uses HTTP requests to
            access and use data. That data can be used to GET, PUT, POST and DELETE data types, which refers to the
            reading, updating, creating and deleting of operations concerning resources.</p>

        <h4>GET / POST requests</h4>
        <style type="text/css">
            .tg {
                border-collapse: collapse;
                border-spacing: 0;
            }

            .tg td {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg th {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: normal;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg .tg-0lax {
                text-align: left;
                vertical-align: top
            }
        </style>
        <table class="tg">
            <thead>
                <tr>
                    <th class="tg-0lax">GET</th>
                    <th class="tg-0lax">POST</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="tg-0lax">used to retrieve information</td>
                    <td class="tg-0lax">used to post data to the server</td>
                </tr>
                <tr>
                    <td class="tg-0lax">data is sent via query string</td>
                    <td class="tg-0lax">data is sent via request body</td>
                </tr>
                <tr>
                    <td class="tg-0lax">information is plainly visible in the URL</td>
                    <td class="tg-0lax">data is NOT visible in the URL</td>
                </tr>
                <tr>
                    <td class="tg-0lax">limited amount of data can be sent (circa 2K characters)</td>
                    <td class="tg-0lax">can send any sort of data (JSON)</td>
                </tr>
                <tr>
                    <td class="tg-0lax">doesn't create side-effects on the server</td>
                    <td class="tg-0lax">creates side-effects on the server</td>
                </tr>
            </tbody>
        </table>

        <h4>Handling POST requests</h4>
        <pre><code>
<span class="red">on HTML file</span>
GET
< form action="http://localhost:3000/tacos" method="get">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>
POST
< form action="http://localhost:3000/tacos" method="post">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>

<span class="red">on the index.js</span>
app.get('/tacos', (req, res) => {
res.send("GET /tacos response")
})
app.post('/tacos', (req, res) => {
res.send("POST /tacos response")
})
</code></pre>
        <p>Parsing the request body:</p>
        <p>Post requests' req object contain an object called <b>req.body</b>. This object must be parsed by a
            middleware in Express, so that we can have access to it.</p>
        <pre><code>
app.use(express.urlencoded({ extended: true }));
<span class="red">this one will parse req.body that came from an HTML form.</span>
<span class="red">app.use tells that everytime it is needed, this will be the way to parse these objects.</span>

app.use(express.json());
<span class="red">this one will parse req.body that came in the JSON format.</span>
</code></pre>
        <p> What is Middleware? It is those methods/functions/operations that are called BETWEEN processing the Request
            and sending the Response in your application method.</p>

        <p> When talking about express.json() and express.urlencoded() think specifically about POST requests (i.e. the
            .post request object) and PUT Requests (i.e. the .put request object)
        </p>
        <p>
            You DO NOT NEED express.json() and express.urlencoded() for GET Requests or DELETE Requests.
        </p>
        <p>
            You NEED express.json() and express.urlencoded() for POST and PUT requests, because in both these requests
            you are sending data (in the form of some data object) to the server and you are asking the server to accept
            or store that data (object), which is enclosed in the body (i.e. req.body) of that (POST or PUT) Request
        </p>
        <p>
            Express provides you with middleware to deal with the (incoming) data (object) in the body of the request.
        </p>
        <p>
            a. express.json() is a method inbuilt in express to recognize the incoming Request Object as a JSON Object.
            This method is called as a middleware in your application using the code: app.use(express.json());
        </p>
        <p>
            b. express.urlencoded() is a method inbuilt in express to recognize the incoming Request Object as strings
            or arrays. This method is called as a middleware in your application using the code:
            app.use(express.urlencoded());
        </p>
        <p>
            ALTERNATIVELY, I recommend using body-parser (it is an NPM package) to do the same thing. It is developed by
            the same peeps who built express and is designed to work with express. body-parser used to be part of
            express. Think of body-parser specifically for POST Requests (i.e. the .post request object) and/or PUT
            Requests (i.e. the .put request object).
        </p>
        <p>
            Using body-parser you can do:
        </p>
        <pre><code>
<span class="red">calling body-parser to handle the Request Object from POST requests</span>
const bodyParser = require('body-parser');
<span class="red">parse application/json, basically parse incoming Request Object as a JSON Object </span>
app.use(bodyParser.json());
<span class="red">parse application/x-www-form-urlencoded, basically can only parse incoming Request Object if strings or arrays</span>
app.use(bodyParser.urlencoded({ extended: false }));
<span class="red">combines the 2 above, then you can parse incoming Request Object if object, with nested objects, or generally any type.</span>
app.use(bodyParser.urlencoded({ extended: true }));
</code></pre>

        <h4>Into to REST</h4>
        <p>What is REST? Representational State Transfer. Also called RESTful.</p>
        <p>REST is an "architectural" style for distributed hypermedia systems. It's basically a set of guidelines for
            how a client + server should communicate and perform CRUD (Create Read Update Delete.Destroy) operations on
            a given resource.</p>
        <p>The main idea of REST is treating data on the server-side as resources that can be CRUDed.</p>
        <p>The most common way of approaching REST is in formatting the URLs and HTTP verbs in your applications.</p>
        <p>Architectural pattern:</p>
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Path</th>
                    <th>Verb</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>index</td>
                    <td>/comments</td>
                    <td>GET</td>
                    <td>Display all comments</td>
                </tr>
                <tr>
                    <td>new</td>
                    <td>/comments/new</td>
                    <td>GET</td>
                    <td>Form to create new comment</td>
                </tr>
                <tr>
                    <td>create</td>
                    <td>/comments</td>
                    <td>POST</td>
                    <td>Creates new comment on server</td>
                </tr>
                <tr>
                    <td>show</td>
                    <td>/comments/:id</td>
                    <td>GET</td>
                    <td>Details for one specific comment</td>
                </tr>
                <tr>
                    <td>edit</td>
                    <td>/comments/:id/edit</td>
                    <td>GET</td>
                    <td>Form to edit specific comment</td>
                </tr>
                <tr>
                    <td>update</td>
                    <td>/comments/:id</td>
                    <td>PATCH</td>
                    <td>Updates specific comment on server</td>
                </tr>
                <tr>
                    <td>destroy</td>
                    <td>/comments/:id</td>
                    <td>DELETE</td>
                    <td>Deletes specific item on server</td>
                </tr>
            </tbody>
        </table>
        <h4>Setting up a REST</h4>
        <pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

const comments = [
    {
        id: 1,
        username: 'Todd',
        comment: 'lol that is sooo funny'
    },
    {
        id: 2,
        username: 'Skyler',
        comment: 'I like to go birdwatching with my dog'
    },
    {
        id: 3,
        username: 'Sk8erBoi',
        comment: 'Plz delete your account, Todd'
    },
    {
        id: 4,
        username: 'onlysayswoof',
        comment: 'woof woof woof'
    }
]

app.get('/comments', (req, res) => {
    res.render('comments/index', { comments })
})
<span class="red">the comments array is being passed through the render function, so that render can "use" the data in this array to create the page</span>

app.get('/tacos', (req, res) => {
    res.send("GET /tacos response")
})

app.post('/tacos', (req, res) => {
    const { meat, qty } = req.body;
    res.send(`OK, here are your ${qty} ${meat} tacos`)
})

app.listen(3000, () => {
    console.log('ON PORT 3000!')
})

<span class="red">on views/comments/index.ejs</span>
< h1>Comments< /h1>
< ul>
<% for(let c of comments){ %>
< li><%=c.comment%> - < b><%= c.username%>< /b>< /li>
<% }%>
< /ul>
</code></pre>

        <h4>RESTful comments new</h4>
        <p>Usually we display (GET) a form for the user to fill, then we submit (POST) the new comment to the server.
        </p>
        <pre><code>
            <span class="red">on index.js</span>
            app.get('/comments/new', (req, res) => {
                res.render('comments/new')
            })

            <span class="red">on new.ejs</span>
            < h1>Make a new comment< /h1>
            < form action="/comments" method="post">
                < section>
                    < label for="username">Enter username:< /label>
                    < input type="text" id="username" name="username">
                < /section>
                < section>
                    < label for="comment">Comment text:< /label>
                    < textarea name="comment" id="comment" cols="30" rows="5">< /textarea>
                    < /section>
                < button>Submit< /button>
            < /form>

            <span class="red">on index.js again</span>
            app.post('/comments', (req, res) => {
                <span class="red">deconstruct req.body object:</span>
                const { username, comment } = req.body;
                <span class="red">push the new comment as an object to the comments array:</span>
                comments.push({ username, comment });
                <span class="red">redirect to the /comments page to see all comments including the new one:</span>
                res.redirect('/comments');
            }
        </code></pre>

        <h4>RESTful comments show</h4>
        <p>To show, edit or delete specific items, we have to point to the items's unique id.</p>
        <pre><code>
            app.get('/comments/:id', (req, res) => {
                <span class="red">destructure req.params object to obtain the requested id:</span>
                const { id } = req.params;
                <span class="red">"find" the requested comments in the comments array (we have to transform the string in a number by using +id or parseInt(id)):</span>
                const comment = comments.find(c => c.id === +id);
                <span class="red">render page with the comment passed through:</span>
                res.render('comments/show', { comment });
            })

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username%>< /h2>
            < a href="comments">Back to all comments< /a>
        </code></pre>

        <h4>Generating random ids with UUID</h4>
        <p>In order to generate unique ids, we can make use of an NPM dependency called UUID.</p>
        <p>After install it using <b>npm i uuid</b>, we have to require it on the script. Here we will use version 4's
            ids (each version provides a different id format). The id created by UUID is a STRING.</p>
        <pre><code>
            <span class="red">on index.js</span>
            const { v4: uuid } = require('uuid');

            const comments = [
                {
                    id: uuid(),
                    username: 'Todd',
                    comment: 'lol that is sooo funny'
                },
                {
                    id: uuid(),
                    username: 'Skyler',
                    comment: 'I like to go birdwatching with my dog'
                },
                {
                    id: uuid(),
                    username: 'Sk8erBoi',
                    comment: 'Plz delete your account, Todd'
                },
                {
                    id: uuid(),
                    username: 'onlysayswoof',
                    comment: 'woof woof woof'
                }
            ]

            <span class="red">also we have to provide an unique id for each new comment:</span>
            app.post('/comments', (req, res) => {
                const { username, comment } = req.body;
                comments.push({ username, comment, id: uuid() });
                res.redirect('comments');
            })

        </code></pre>

        <h4>RESTful requests update</h4>
        <p>To update (edit, modify) an existing item, we can use the verbs PUT, PATCH or POST.</p>
        <p>PUT is used to replace all current representations of the target resource with the payload.</p>
        <p>PATCH is used to apply partial modifications to a resource.</p>
        <p>POST is used to create a completely new resource item.</p>
        <pre><code>
            app.patch('comments/:id', (req, res) => {
                <span class="red">deconstruct id from the req.params object:</span>
                const { id } = req.params;
                <span class="red">"find" that specific comment in our comments array:</span>
                const foundComment = comments.find(c => c.id === id)
                <span class="red">(because we're using UUID, and the ID generated by UUID is a string, we don't need to transform it into a number)</span>
                <span class="red">obtaining the new comment from the req.body object (we could also desctructure/rename it):</span>
                const newCommentText = req.body.comment;
                <span class="red">redirect to index.ejs:</span>
                res.redirect('/comments');
            })
        </code></pre>
        <p>The route in the server that will update (patch) the item is ready. Now we must create a form
            (comments/:id/edit) for the user to fill the new input data.</p>
        <pre><code>
            <span class="red">on index.js</span>
            app.get('comments/:id/edit', (req, res) => {
                const { id } = req.params;
                const comment = comments.find(c => c.id === id);
                res.render('comments/edit', { comment })
            })

            <span class="red">on edit.ejs</span>
            < h1>Edit< /h1>
            < form action="/comments/<%=comment.id%>">
                < textarea name="comment" id="" cols="30" rows="10">
                    <%= comment.comment %>
                    <span class="red">this will show the current text for the user to update as she wants</span>
                </ textarea>
                < button>Save< /button>
            < /form>

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username %>< /h2>
            < a href="/comments">Back to index< /a>
            < a href="/comments/<%=comments.id%>/edit">Edit comment< /a>
        </code></pre>
        <p>An HTML form does not support PATCH method, only supports GET and POST. So we have to install a dependency
            called 'method-override'.After installing, requiring and app.use ing this, we need to add to the form's
            action attribute: <b>?_method=PATCH</b>, and also define the method attribute as <b>"post"</b>.</p>
        <pre><code>
            <span class="red">on terminal</span>
            npm i method-override

            <span class="red">on index.js</span>
            const methodOverride = require('method-override');
            app.use(methodOverride('_method'));

            <span class="red">on edit.ejs</span>
            < h1>Edit< /h1>
            < form <b>method="post"</b> action="/comments/<%=comment.id%><b>?_method=PATCH</b>">
                < textarea name="comment" id="" cols="30" rows="10">
                    <%= comment.comment %>
                </ textarea>
                < button>Save< /button>
            < /form>
        </code></pre>

        <h4>RESTful comments delete</h4>
        <p>Same as PATCH, DELETE method is not supported as a method in HTML forms (they only accept GET or POST), so we
            have to use 'method-override' in order to "fake it".</p>
        <pre><code>
            <span class="red">on index.js</span>
            app.delete('/comments/:id', (req, res) => {
                const { id } = req.params;
                comments = comments.filter(c => c.id !== id);
                res.redirect('/comments');
            })

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username %>< /h2>
            < a href="/comments">Back to index< /a>
            < a href="/comments/<%=comments.id%>/edit">Edit comment< /a>
            < form method="post" action="/comments/<%=comment.id%>?_method=DELETE">
                < button>Delete< /button>
            < /form>
        </code></pre>

        <h2>MongoDB</h2>
        <p>According to Mongo's homepage, it is "the most popular database for modern applications". It is commonly used
            in combination with Node.</p>
        <p>Mongo is a document database, which we can use to store and receive complex data from.</p>
        <p>Why use a database, instead of just saving to a file?
        <ul>
            <li>Databases can handle large amounts of data efficiently and store ir compactly</li>
            <li>They provide tools for easy insertion, querying and uploading of data</li>
            <li>They generally offer security features and control over access to data</li>
            <li>They generally scale well</li>
        </ul>
</p>

<h4>SQL vs. NoSQL databases</h4>
<p>Structured Query Language (SQL) databases are relational databases. We pre-define a schema of tables before we insert
    anything. Ex.: MySQL, Postgres, SQLite, Oracle, Microsoft SQL Server.</p>
<p>No-SQL databases do not use SQL. There are many types of no-sql databases, inluding document, key-value and graph
    stores. Ex.: MongoDB, CouchDB, Neo4j, Cassandra, Redis.</p>

<h4>Why using Mongo?</h4>
<ul>
    <li>Mongo is very commonly used with Node and Express (MEAN & MERN stacks' ME stands for Mongo and Express)</li>
    <li>It's easy to get started with (though it can be tricky to truly master)</li>
    <li>It plays particularly well with JavaScript</li>
    <li>Its popularity also means there is a strong community of developers using Mongo</li>
</ul>

<h4>Running Mongo (mongosh)</h4>
<p>To start Mongo, write on Terminal:</p>
<pre><code>
    brew services start mongodb-community@6.0
</code></pre>
<p>Then, write 'mongosh' to start the shell from where you can control it, create databases, etc.</p>
<p>To create a new database: 'use databaseName'</p>
<p>To show existent databases: 'show dbs' or 'show databases'</p>

<h4>JSON & BSON</h4>
<p>JSON and BSON are close cousins, as their nearly identical names imply, but you wouldn’t know it by looking at them
    side-by-side. JSON, or JavaScript Object Notation, is the wildly popular standard for data interchange on the web,
    on which BSON (Binary JSON) is based. </p>
<p>BSON, or Binary JSON, is the data format that MongoDB uses to organize and store data. This data format includes all
    JSON data structure types and adds support for types including dates, different size integers, ObjectIds, and binary
    data.</p>
<p>MongoDB allows developers to query and manipulate objects by specific keys inside the JSON/BSON document, even in
    nested documents many layers deep into a record, and create high performance indexes on those same keys and values.
    When using a MongoDB driver in your language of choice, it’s still important to know that you’re accessing BSON data
    through the abstractions available in that language.</p>

<h3>Mongo syntax</h3>
<p>A collection is a grouping of MongoDB documents. Documents within a collection can have different fields. A
    collection is the equivalent of a table in a relational database system. Documents are individual records in a
    MongoDB collection and are the basic unit of data in MongoDB.</p>

<h4>Inserting</h4>
<p>The method insert() stands for the C in CRUD.</p>
<p>Adding a new collection in the animalShelter database:</p>
<pre><code>
    db.dogs.insertOne({name: "Charlie", age: 3, breed: "corgi", carFriendly: true})
    <span class="red">pass a normal JS object inside the insertOne() method.</span>

    show collections
    //dogs

    <span class="red">to see what's inside the dogs collection:</span>
    db.dogs.find()
//[
  {
    _id: ObjectId("630a8a06977e8686019719df"),
    name: 'Charlie',
    age: 3,
    breed: 'corgi',
    carFriendly: true
  }
]
</code></pre>
<p>Mongo sets an unique _id for each document (item) included inside a collection.</p>
<p>db.collectionName.insertOne() inserts one document at a time.</p>
<p>db.collectionName.insertMany() inserts several documents at a time (an array of objects).</p>
<p>db.collectionName.insert() does both things.</p>
<p>Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.</p>
<pre><code>
    db.dogs.insert([{name: "Wyatt", breed: "Golden", age: 14, catFriendly: false}, {name: "Tonya", breed: "Chihuahua", age: 17, catFriendly: true}])

    db.dogs.find()
    //[
    {
      _id: ObjectId("630a8a06977e8686019719df"),
      name: 'Charlie',
      age: 3,
      breed: 'corgi',
      carFriendly: true
    },
    {
      _id: ObjectId("630a8e0f977e8686019719e0"),
      name: 'Wyatt',
      breed: 'Golden',
      age: 14,
      catFriendly: false
    },
    {
      _id: ObjectId("630a8e0f977e8686019719e1"),
      name: 'Tonya',
      breed: 'Chihuahua',
      age: 17,
      catFriendly: true
    }
  ]  

    db.cats.insert({name: "Blue Steele", age: 6, dogFriendly: false, breed: "Scottish Fold"})
</code></pre>

<h4>Finding</h4>
<p>The method find() stands for the R in CRUD.</p>
<p>db.collectionName.find() gives all the documents in that collection.</p>
<p>db.collectionName.find({breed: "Corgi"}) will return all documents with that query (case sensitive).</p>
<p><b>db.collectionName.findOne({catFriendly: true})</b> will find one result for that query.</p>

<h4>Updating</h4>
<pre><code>
    db.dogs.updateOne({name: 'Charlie'}, {$set: {age: 4, color: 'chocolate'}})
    <span class="red">sets the age to 4 and creates color key with value 'chocolate'</span>

    db.dogs.updateMany({catFriendly: true}, {$set: {isAvailable: false}})
    <span class="red">in all documents with catFriendly set to true, it sets isAvailable property to false.</span>

    db.cats.updateOne({age: 6}, {$set: {age: 7}, $currentDate: {lastChanged: true}})
    db.cats.find()
    //{ "_id" : ObjectId("5f3c98f5feaedbe6667d5df8"), "name": "Blue Steele", "age": 7, "dogFriendly": false, "breed": "Scottish fold", "lastChanged": ISODate("2022-08-26T05:51:18.584Z") }
    <span class="red">$currentDate is another operator that sets the value of the mentioned property as today's current date.</span>

    db.cats.replaceOne({etcetc: etcetc}, {etcetc:etcetc, etcetc:etcetc})
    <span class="red">replaces an entire document with new data, maintaining the _id</span>
</code></pre>

<h4>Deleting</h4>
<pre><code>
    db.cats.deleteOne({name: "Blue Steele"})

    db.dogs.deleteMany({catFriendly: false})

    db.dogs.deleteMany({})
    <span class="red">deletes all documents in the dogs collection</span>
</code></pre>

<h4>Aditional Mongo operators</h4>
<pre><code>
    db.dogs.find({'personality.childFriendly': true})
    <span class="red">selects the childFriendly property that is nested inside the personality property</span>

    db.dogs.find({age {$gt: 8}})
    <span class="red">finds dogs with an age greater than 8</span>

    db.dogs.find({age {$gte: 8}})
    <span class="red">finds dogs with an age greater or equal to 8</span>

    db.dogs.find({age {$lt: 8}})
    <span class="red">finds dogs with an age lesser than 8</span>

    db.dogs.find({age {$lte: 8}})
    <span class="red">finds dogs with an age lesser or equal to 8</span>

    db.dogs.find({breed: {$in: ['Mutt', 'Corgi']}})
    <span class="red">finds dogs with breed set to Mutt OR Corgi</span>

    db.dogs.find({breed: {$ne: 'Corgi'}})
    <span class="red">finds dogs with breeds not equal to Corgi</span>

    db.dogs.find({breed: {$nin: ['Mutt', 'Chihuahua']}})
    <span class="red">finds dogs that have breed set to neither Mutt or Chihuahua</span>

    db.dogs.find({$or: [{'personality.catFriendly: true'}, {age: {$lte: 2}}]})
    <span class="red">finds dogs that are either cat friendly or with an age less or equal to 2</span>
</code></pre>

<h3>Mongoose</h3>
<p>Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It manages relationships between data,
    provides schema validation, and is used to translate between objects in code and the representation of those objects
    in MongoDB.</p>
<p>ODMs like Mongoose map documents coming from a database into usable JavaScript objects. Mongoose provides ways for us
    to model out our application data and define a schema. It offers easy ways to validate data and build complex
    queries from the comfort of JS.</p>

<h4>Setting up Mongoose</h4>
<pre><code>
    <span class="red">on Terminal</span>
    npm init 
    <span class="red">initiate npm</span>

    npm i mongoose
    <span class="red">install Mongoose</span>

    <span class="red">on index.js</span>
    const mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost:27017/movieApp');
    <span class="red">27017 is the default Mongo port; movieApp is the name of our database</span>

    <span class="red">on Terminal</span>
    node index.js
    <span class="red">this will try to connect with the selected port via mongoose</span>
</code></pre>
<p>Catching connection errors:</p>
<pre><code>
    <span class="red">mongoose.connect() returns a promise, so we can handle errors using then/catch:</span>
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/movieApp')
    .then(() => {
        console.log('CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO ERROR!!!!');
        console.log(err)
    })
</code></pre>

<h4>Mongoose Models</h4>
<p>For each collection, we have to define a Model. A Model in Mongoose is a sort of JavaScript Class.</p>
<p>To define a Model, first we have to set its Schema. A Schema is a map for keys in Mongo for different types in JS.
</p>
<pre><code>
    <span class="red">on index.js</span>
    const movieSchema = new mongoose.Schema({
        title: String,
        year: Number,
        score: Number,
        rating: String
    })
</code></pre>
<p>Then, create a model from that schema using mongoose.model. The first argument in mongoose.model is the model's name
    (always capitalized), the second argument is the schema's name. Mongoose will automatically create a collection
    using the model's name, in lowercase and plural (Movie -> movies).</p>
<pre><code>
    <span class="red">on index.js</span>
    const Movie = mongoose.model('Movie', movieSchema);
</code></pre>
<p>Creating a new Movie instance:</p>
<pre><code>
    <span class="red">on index.js</span>
    const amadeus = new Movie({title: 'Amadeus', year: 1986, score: 9.2, rating: 'R'});
</code></pre>
<p>This creates an object that is an instance of the Movie class on the JS file. It also creates an '_id' property with
    an unique id for that item. To save it to the collection movies on
    the database movieApp, we have to use .save()</p>
<pre><code>
    <span class="red">on index.js</span>
    amadeus.save();
</code></pre>

<h4>insertMany in Mongoose</h4>
<p>insertMany accepts an array of objects and creates several documents at the same time. Documents are automatically
    saved in the database (no need to call .save()).</p>
<pre><code>
    <span class="red">on index.js</span>
    Movie.insertMany([
    { title: 'Amelie', year: 2001, score: 8.3, rating: 'R' },
    { title: 'Alien', year: 1979, score: 8.1, rating: 'R' },
    { title: 'The Iron Giant', year: 1999, score: 7.5, rating: 'PG' },
    { title: 'Stand By Me', year: 1986, score: 8.6, rating: 'R' },
    { title: 'Moonrise Kingdom', year: 2012, score: 7.3, rating: 'PG-13' }
])
</code></pre>

<h4>Finding in Mongoose</h4>
<p>The .find() method in Mongoose returns a thenable query. It is not exactly a promise, but can be handled with
    .then().</p>
<pre><code>
    Movie.find({rating: 'PG-13'}).then(data => console.log(data))
</code></pre>
<p>By using .exec(), we get a real promise, that can be handled with async/await.</p>
<p>.findById('idNumber') is also a very commonly used method.</p>
<pre><code>
    Movie.findById('630bdc37e79dab934485e0b9').then(m => console.log(m));
    // {
        _id: ObjectId("630bdc37e79dab934485e0b9"),
        title: 'Alien',
        year: 1979,
        score: 8.1,
        rating: 'R',
        __v: 0
      }
</code></pre>

<h4>Updating in Mongoose</h4>
<p>The syntax is similar to Mongo's, but without $set.</p>
<pre><code>
    Movie.updateOne({title: 'Amadeus'}, {year: 1984}).then(res => console.log(res));
    <span class="red">will update the year in the document with title 'Amadeus' to 1984</span>
</code></pre>
<p>Updating more than one document:</p>
<pre><code>
    Movie.updateMany({title: {$in: ['Amadeus', 'Stand By Me']}}, {score: 10}).then(res => console.log(res))
    <span class="red">updates the documents with title Amadeus or Stand By Me to have score equal to 10</span>
</code></pre>
<p>By using .findOneAndUpdate with the option 'new' set to true, the thenable query will return the new updated
    document.</p>
<pre><code>
    Movie.findOneAndUpdate({title: 'The Iron Giant'}, {score: 7.8}, {new: true}).then(m => console.log(m))
</code></pre>

<h4>Deleting with Mongoose</h4>
<pre><code>
    Movie.deleteOne({year: {$gte: 1999}}).then(msg => console.log(msg))
    <span class="red">deletes the first occurance</span>

    Movie.deleteMany({year: {$gte: 1999}}).then(msg => console.log(msg))
    <span class="red">delete all</span>

    Movie.findOneAndDelete({title: 'Alien'}).then(m => console.log(m))
    <span class="red">delete one and returns the deleted item</span>
</code></pre>

<h4>Mongoose Schema validations</h4>
<p>In Mongoose, it is possible to set a property to required. If the property is not in the new instance of the model
    created within this Schema, the insertion of that instance-document will not be validated.</p>
<p>Likewise, if the value of any property doesn't match with the type defined on Schema, it also won't be validated -
    unless, for example, it is a string like '522' in a type-Number property, in this case it will be converted to a
    number.</p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
        },
    })
    
    const Product = mongoose.model('Product', productSchema);
    
    const bike = new Product({ name: 'Mountain Bike', price: 599 })
    bike.save()
        .then(data => {
            console.log('IT WORKED!')
            console.log(data)
        })
        .catch(err => {
            console.log('OH NO ERROR!!!!')
            console.log(err)
        })
</code></pre>

<h4>Additional Schema Constraints</h4>
<p>We can define default values for properties on Schemas, as well nest properties. More constraints can be found at
    https://mongoosejs.com/docs/guide.html#definition </p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: 0
            <span class="red">minimum price will be 0</span>
        },
        onSale: {
            type: Boolean,
            default: false
            <span class="red">default value is false</span>
        },
        categories: {
            type: [String],
            <span class="red">it must be an array, only consisting of strings</span>
            default: ['Cycling']
        },
        qty: {
            online: {
                type: Number,
                default: 0
            },
            inStore: {
                type: Number,
                default: 0
            }
        },
        size: {
            type: String,
            enum: ['S', 'M', 'L']
            <span class="red">enum: value must be one of the items of this array</span>
        }
    })
    
    const Product = mongoose.model('Product', productSchema);
    
    const bike = new Product({ name: 'Bike Helmet', price: 599, categories: ['Cycling', 'Safety'], qty: { online: 12, inStore: 2} })
    bike.save()
        .then(data => {
            console.log('IT WORKED!')
            console.log(data)
        })
        .catch(err => {
            console.log('OH NO ERROR!!!!')
            console.log(err)
        })
</code></pre>

<h4>Validating Mongoose Updates</h4>
<p>Whenever we want to update a document in using Mongoose, we have to set the option <b>runValidators</b> to true, in
    order to Mongoose refer again to the Schema validators, and evaluate the inserted properties according to them.</p>
<pre><code>
    Product.findOneAndUpdate({ name: 'Tire Pump' }, {price: 29.99}, {new: true, runValidators: true})
        .then(data => {
            console.log('IT WORKED')
            console.log(data)
        })
        .catch(err => {
            console.log('ERROR!')
            console.log(err)
        })
</code></pre>

<h4>Mongoose Validation Errors</h4>
<p>We can pass error messages to each of the constraints on a Schema.</p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: [0, 'Price must be positive ya dodo!']
            <span class="red">custom error has been set up</span>
        },
        onSale: {
            type: Boolean,
            default: false
        },
        categories: {
            type: [String],
            default: ['Cycling']
        },
        qty: {
            online: {
                type: Number,
                default: 0
            },
            inStore: {
                type: Number,
                default: 0
            }
        }
    })
</code></pre>

<h4>Model Instance Methods</h4>
<p>As in JS Classes, we can create methods inside a Mongoose Schema. These methods will be available in every instance
    of that Schema.</p>
<p>Ex.: creating a method to toggle 'onSale' value from true to false and vice versa:</p>
<pre><code>
    productsSchema.methods.toggleOnSale = function(){
        this.onSale = !this.onSale;
        return this.save();
        <span class="red">'this' will refer to the particular instance where the method was called. Remember that 'this.save()' will return a promise.
        </span>
    }

    const findAndtoggleOnSale = async () => {
        const foundProduct = await Product.findOne({name: 'Mountain Bike'});
        await foundProduct.toggleOnSale();
        console.log(foundProduct);
    }
</code></pre>

<h4>Adding Model Static Methods</h4>
<p>In static methods, the keyword 'this' refer to the Model itself, not to a specific instance.</p>
<p>Ex.: creating a fireSale method, which sets all prices to 0 and puts every instance on sale.</p>
<pre><code>
    productSchema.statics.fireSale = function(){
        return this.updateMany({}, {onSale: true, price: 0})
    }

    Product.fireSale().then(res => console.log(res));

</code></pre>

<h4>Mongoose Virtuals</h4>
<p>Virtuals are "methods" that simulate properties that actually won't be saved in the database, but can retrieved in an
    easy manner.</p>
<pre><code>
    <span class="red">on person.js</span>
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/shopApp')
    .then(() => {
        console.log('CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO ERROR!!!!');
        console.log(err)
    })

    <span class="red">defining a Schema</span>
    const personSchema = new mongoose.Schema({
        first: String,
        last: String
    })

    <span class="red">defining a virtual fullName</span>
    personSchema.virtual('fullName').get(function(){
        return `${this.first} ${this.last}`
    })

    <span class="red">defining a Model</span>
    const Person = mongoose.model('Person', personSchema);

    <span class="red">creating a document (instance)</span>
    const tammy = new Person({first: 'Tammy', last: 'Chow'})
    tammy.save();
    <span class="red">the collection will be called 'people' because Mongo automatically pluralize model's name</span>

    console.log(tammy.fullName);
    //'Tammy Chow'    
</code></pre>
<p>There are also virtual setters (just put .set() after get() and pass in a function), which will actually update the
    values of the properties in the document.</p>

<h4>Mongoose Middlewares</h4>
<p>The Mongoose Middleware are pieces of code that can be executed 'before' or 'after' a method is executed. For
    example, if we remove a user from the database, we will also want to remove all of his comments, posts, etc on the
    database.</p>
<p>Middleware are always executed inside of asynchronous functions.</p>
<pre><code>
    personSchema.pre('save', async function(){
        console.log('ABOUT TO SAVE!');
    });
    <span class="red">this function will run before every save()</span>

    personSchema.post('save', async function(){
        console.log('JUST SAVED!');
    })
    <span class="red">this function will run after every save()</span>

</code></pre>

<h2>Mongoose with Express</h2>
<p>In this section, we learn how to create a simple app, connecting UI to CRUDs via Express, and connecting Express to
    Mongo Server via Mongoose.</p>
<p>UI ---CRUD---> Express ---> Mongoose ---> MongoDB</p>
<h4>Express + Mongoose basic setup</h4>
<pre><code>
    <span class="red">on terminal</span>
    npm init -y 
    npm i express ejs mongoose

    <span class="red">on index.js</span>
    const express = require('express');
    const app = express();
    const path = require('path');
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/farmStand')
    .then(() => {
        console.log('MONGO CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO Mongo connection ERROR!!!!');
        console.log(err)
    })

    app.set('views', path.join(__dirname, 'views'));
    app.set('view engine', 'ejs');

    app.get('/dog', (req, res) => {
        res.send('WOOF!');
    })

    app.listen(3000, () => {
        console.log('APP IS LISTENING ON PORT 3000!')
    })
</code></pre>

<h4>Creating our Model (E+M)</h4>
<p>We'll start by creating a 'models' folder; each model will be kept in a single .js file. On each model file, we have
    only to require 'mongoose'; we are not connecting to the database from this files; instead, we are requiring this
    model files into index.js, which will connect them and feed the database.</p>
<pre><code>
    <span class="red">on models/products.js</span>
    const mongoose = require('mongoose');

    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: 0
        },
        category: {
            type: String,
            enum: ['fruit', 'vegetable', 'dairy']
        }
    })

    const Product = mongoose.model('Product', productSchema);

    module.exports = Product;

    <span class="red">on index.js</span>
    const Product = require('./models/product')
</code></pre>
<p>In order to feed the database with new data whenever needed, we'll create a 'seeds.js' file; this file is created
    only for development purposes. This file will require the models and also connect to Mongoose.</p>
<pre><code>
    <span class="red">on seeds.js</span>
    <span class="red">requiring Product and mongoose, connecting to mongodb via mongoose</span>
    const mongoose = require('mongoose');

    const Product = require('./models/product')

    mongoose.connect('mongodb://localhost:27017/shopApp')
    .then(() => {
        console.log('MONGO CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO Mongo connection ERROR!!!!');
        console.log(err)
    })

    <span class="red">creating a new product document</span>
    const p = new Product({
        name: 'Ruby Grapefruit',
        price: 1.99,
        category: 'fruit'
    });
    p.save().then(p => {
        console.log(p);
    })
    .catch(e => {
        console.log(e)
    })

    <span class="red">on node shell on terminal:</span>
        node seeds.js

    <span class="red">on mongoose shell on terminal</span>
        show dbs 
        use farmStand 
        show collections
        db.products.find()
        <span class="red">//the document for 'Ruby Grapefruit' will appear here</span>
</code></pre>
<p>Seeding the database with more products:</p>
<pre><code>
    const seedProducts = [
    {
        name: 'Fairy Eggplant',
        price: 1.00,
        category: 'vegetable'
    },
    {
        name: 'Organic Goddess Melon',
        price: 4.99,
        category: 'fruit'
    },
    {
        name: 'Organic Mini Seedless Watermelon',
        price: 3.99,
        category: 'fruit'
    },
    {
        name: 'Organic Celery',
        price: 1.50,
        category: 'vegetable'
    },
    {
        name: 'Chocolate Whole Milk',
        price: 2.69,
        category: 'diary'
    },
]

Product.insertMany(seedProducts)
    .then(res => {
        console.log(res)
    })
    .catch(e => {
        console.log(e)
    })
</code></pre>

<h4>Generating products index page</h4>
<p>Now we go back to index.js and request the products documents from the database:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const products = await Product.find({});
        console.log(products);
        res.send('ALL PRODUCTS WILL BE HERE!');
    })
</code></pre>
<p>We will create a folder called 'views', inside of it create a folder called 'products'. Inside the 'products' folder,
    create a file called 'index.ejs'. Now we can render './views/products/index.ejs' as our get response:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const products = await Product.find({});
        console.log(products);
        res.render('products/index', { products });
        <span class="red">don't forget to pass { products } through the render to get access to them on 'index.ejs'.</span>
    })
</code></pre>

<h4>Products details page</h4>
<p>Creating a default details page for the products:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/:id', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findById(id);
        res.render('products/show', { product });
    })

    <span class="red">on views/products/show.ejs</span>
    < h1>
        <%= product.name %>
    < /h1>
    < ul>
        < li>Price: $<%= product.price %>
        < /li>
        < li>Category: <%= product.category %>
        < /li>
    < /ul>
</code></pre>
<p>Now on the 'all products' page (views/products/index.ejs) we can transform each product's name into a link to its
    details page:</p>
<pre><code>
    < h1>All Products</h1>
    < ul>
        <% for(let product of products) { %>
            < li>
                < a href="/products/<%=product._id%>">
                    <%= product.name %>
                < /a>
            < /li>
            <% } %>
    < /ul>
</code></pre>

<h4>Creating new products</h4>
<p>In order to create new products, we first have to define a GET route to a form, where the user will provide the new
    product data. Then we have to create a POST route to actually insert the new product's data into the database.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/new', (req, res) => {
        res.render('products/new');
    })

    <span class="red">on views/products/new.ejs</span>
    <h1>Add a Product</h1>
    <form action="/products" method="POST">
        < label for="name">Product name: </ label>
        < input type="text" name="name" id="name" placeholder="product name">
        < label for="price">Price (unit): < /label>
        < input type="number" id="price" name="price" placeholder="price">
        < label for="category">Select category: < /label>
        < select name="category" id="category">
            < option value="fruit">fruit< /option>
            < option value="vegetable">vegetable</ option>
            < option value="diary">diary< /option>
        < /select>
        < button>Add product< /button>
    < /form>
</code></pre>
<p>Defining POST route:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.use(express.urlencoded({extended: true}));
    <span class="red">remember, this is necessary to get access to the submitted form queries/values</span>

    <span class="red">still on index.js</span>
    app.post('/products', async (req, res) => {
        const newProduct = new Product(req.body);
        await newProduct.save();
        res.redirect(`/products/${newProduct._id}`);
    })
</code></pre>
<p>Now put a link to the form on the product's index page:</p>
<pre><code>
    <span class="red">on index.ejs</span>
    < a href="/products/new">Add new product< /a>
</code></pre>

<h4>Updating products (E+M)</h4>
<p>As with creating new products, first we have to define a GET route to a form page, then create an 'edit.ejs' page,
    then define a POST route to
    update the database.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/:id/edit', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findById(id)
        res.render('products/edit', { product });
    })

    <span class="red">on views/products/edit.ejs</span>
    < h1>Edit Product</h1>
    < form action="/products/<%=product._id%>" method="POST">
        < label for="name">Product name: < /label>
        < input type="text" name="name" id="name" placeholder="product name" value="<%=product.name%>">
        < label for="price">Price (unit): < /label>
        < input type="number" id="price" name="price" placeholder="price" value="<%=product.price%>">
        < label for="category">Select category: < /label>
        < select name="category" id="category">
            < option value="fruit">fruit< /option>
            < option value="vegetable">vegetable< /option>
            < option value="diary">diary< /option>
        < /select>
        < button>Submit< /button>
    < /form>
</code></pre>
<p>To define an update route, we must use PUT or PATCH verbs. But, remember, HTML forms don't accept these verbs, only
    accept POST or GET, so we have to install, require and use the 'method-override' package.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i method-override

    <span class="red">on index.js</span>
    const methodOverride = require('method-override');
    app.use(methodOverride('_method'));

    <span class="red">on edit.ejs</span>
    < form action="/products/<%=product._id%>?_method=PUT" method="POST">< /form>

    <span class="red">on index.js</span>
    app.put('/products/:id', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findByIdAndUpdate(id, req.body, { runValidators: true, new: true });
        res.redirect(`/products/${product._id}`);
    })
</code></pre>
<p>Now we have to put a link in each product details page.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    < a href="/products/<%=product._id%>/edit">Edit Product</a>
</code></pre>
<p>And put a link on edit page to cancel edit:</p>
<pre><code>
    < a href="/products/<%=product._id%>">Cancel</a>
</code></pre>
<p>This part is just a small detail. On the edit page, the actual category of the product will not be presented, unless
    we add some logic there. There is an HTML attribute called selected, which accepts a boolean as its value. If it is
    true, then the option will be set to selected as default.</p>
<pre><code>
    <span class="red">on edit.ejs</span>
    < select name="category" id="category">
        < option value="fruit" <%=product.category==='fruit' ? 'selected' : '' %>>fruit< /option>
        < option value="vegetable" <%=product.category==='vegetable' ? 'selected' : '' %>>vegetable< /option>
        < option value="diary" <%=product.category==='diary' ? 'selected' : '' %>>diary< /option>
    < /select>
</code></pre>

<h4>Deleting products (E+M)</h4>
<p>As with updating, in order to make a DELETE request using a HTML form, we have to make use of 'method-override'.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    < form action="/products/<%=product._id%>?_method=DELETE" method="POST">
        < button>Delete</ button>
    < /form>
</code></pre>

<h4>Bonus: Filtering by Category</h4>
<p>To show a page with all vegetables, all fruits or all dairies, we will add query strings to the request when clicking
    a category name.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    <ul>
        <li>Price: $<%= product.price %>
        </li>
        <li>Category: <a href="/products?category=<%= product.category %>">
                <%= product.category %>
            </a>
        </li>
    </ul>

    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const { category } = req.query;
        if (category) {
            const products = await Product.find({ category: category });
            res.render('products/index', { products, category });
        } else {
            const products = await Product.find({}); res.render('products/index', { products, category: 'All' });
        }
    })

    <span class="red">on index.ejs</span>
    <h1>
        <%= category %> Products
    </h1>
</code></pre>

<h3>Middlewares in Express</h3>
<p>Here begins Colt's section 40.</p>
<p>Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.</p>
<p>Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.</p>
<p>Middlewares can end the HTTP request by sending back a response with methods like <b>res.send()</b>. Or middlewares can be chained together, one after another by calling <b>next()</b>.</p>

<h4>next()</h4>
<p>As we talked earlier, <b>app.use(< somemiddleware>)</b> will be executed in every single request that is made. The function <b>nest()</b> can be called in order to keep executing the next middlewares inside of other routes that match the requested path.</p>
<pre><code>
    app.use((req, res, next) => {
        console.log('THIS IS MY FIRST MIDDLEWARE!');
        return next();
    })
    app.use((req, res, next) => {
        console.log('THIS IS MY SECOND MIDDLEWARE!');
        return next();
    })
    <span class="red">for every HTTP request, will log:
        //THIS IS MY FIRST MIDDLEWARE!
        //THIS IS MY SECOND MIDDLEWARE!
        and then search for any matching route
    </span>
</code></pre>
<pre><code>
    app.use((req, res, next)=> {
        console.log(req.path, req.method.toUpperCase());
        next();
    })
    <span class="red">will console.log the path and the method of every request</span>
</code></pre>

<h4>Setting up a 404 route</h4>
<p>As the last route on our file, just before app.listen, we can write an app.use to catch all the NOT FOUND requests:</p>
<pre><code>
    app.use((req, res) =>{
        res.status(404).send('NOT FOUND!');
        <span class="red">status(404) will set the status of the response to 404</span>
    })
</code></pre>


/usr/local/Cellar/mongodb-community/6.0.1/bin





<script src="app.js"></script>

</html>