<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node etc.</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Node etc.</h1>
    <p>Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on a JavaScript
        Engine (i.e. V8 engine) and executes JavaScript code outside a web browser, which was designed to build scalable
        network applications. Node.js lets developers use JavaScript to write command line tools and for server-side
        scriptingâ€”running scripts server-side to produce dynamic web page content before the page is sent to the user's
        web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application
        development around a single programming language, rather than different languages for server-side and
        client-side scripts.</p>
</body>
<h3>Running .js files using Node</h3>
<p>On the terminal:</p>
<pre><code>
    node firstScript.js
    <span class="red">the JS file will run inside the terminal</span>
</code></pre>
<h3>Process</h3>
<p>The process object is a global that provides information about, and control over, the current Node.js process. As a
    global, it is always available to Node.js applications without using require().</p>
<p>We can compare process to the window object on a browser.</p>
<h3>process.argv</h3>
<p>The process.argv property returns an array containing the command line arguments passed when the Node.js process was
    launched. The first element will be process.execPath. The process.execPath property returns the absolute pathname of
    the executable that started the Node.js process: usually '/usr/local/bin/node'. The second element will be the path
    to the JavaScript file being executed. The remaining elements will be any additional command line arguments.</p>
<pre><code>
    node firstScript.js puppies chickens hello
    <span class="red">these 3 strings will be added to the argv array.</span>
</code></pre>
<p>process.argv returns an array, and can be accessed from the js file.</p>

<h3>File System Module (fs)</h3>
<p>The fs module enables interacting with the file system. </p>
<p>All file system operations have synchronous, callback, and promise-based forms.</p>
<p>Unlike the process object, the fs module must be required before being used in the script.</p>
<p>Example: creating a script that creates boilerplates files (index.html, style.css, app.js) for a new project.</p>
<pre><code>
on script:
const fs = require('fs'); <span class="red">requires fs module</span>
const folderName = process.argv[2] || 'Project'; <span class="red">accesses the argument that was provided by the user</span>
fs.mkdirSync(folderName); <span class="red">creates a folder with the name provided by the user</span>
fs.writeFileSync(`${folderName}/index.html`, '');
fs.writeFileSync(`${folderName}/style.css`, '');
fs.writeFileSync(`${folderName}/app.js`, '')
<span class="red">creates these 3 files inside that folder. The second argument is the content of that file and can be set to empty.</span>

async version:
fs.mkdir(`${folderName}`, { recursive: true }, (err) => {
    console.log('The folder is successfully created')
    if (err) console.log(err);
 })
fs.writeFile(`${folderName}/index.html`, 'I am the new file\'s content', (err) => {
    console.log('The HTML file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/style.css`, 'I am the new file\'s content', (err) => {
    console.log('The CSS file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/app.js`, 'I am the new file\'s content', (err) => {
    console.log('The JS file is successfully created')
    if (err) console.log(err)
 });
 
on the command line:
node boilerplate.js Portfolio
<span class="red">creates a folder called Portfolio with those 3 files inside of it.</span>
</code></pre>

<h3>Exporting modules using module.export</h3>
<p>In order to create our own modules, the first thing to do is to put the value inside of module.exports object in the
    module's file.</p>
<p>Then we have to require the module using require('./moduleName') inside the file where we want to use it.</p>
<pre><code>
    on the module:
    module.exports.sum = (x,y) => x + y;
    exports.sum = (x,y) => x + y;
    <span class="red">exports is a shortcut for module.exports</span>

    on the script using the model:
    require('./math');
    <span class="red">assuming that the module's file is called math.js</span>
</code></pre>

<h3>Requiring a directory</h3>
<p>When requiring an entire folder, node.js will look into index.js, which should be inside that folder.</p>
<p>A common pattern is to require all values into index.js and then export them all from there.</p>

<h2>NPM</h2>
<p>NPM is the largest library of packages, which are modules written by other people, all ready for anyone to use.</p>
<p>NPM is also a command line tool to easily install and manage those packages in our Node projects.</p>

<h3>Installing packages from NPM</h3>
<p>To install a package from NPM, the basic command is: npm install packageName . This command has a shortcut: npm i
    packageName .</p>
<p>The correct packageName can be found in the package's documentation on NPM website.</p>
<p>To globally install a package, just add -g</p>
<pre><code>
    npm i packageName -g 
</code></pre>
<p>The global installation will install the package on the root of the computer, so that every project that requires
    that package will have it available. If the global installation fails, use this line to change permission:</p>
<pre><code>
sudo chown -R $USER/usr/local/lib/node_modules
</code></pre>

<h3>The <i>package.json</i> file</h3>
<p>Before installing any package to a projects folder, we have to run <b>npm init</b>. This will create a package.json
    file in the root of that project. This file contains metadata of the packages used by that project. Everytime we
    install a new package on that folder, this file will automatically update the <b>dependencies</b> property.</p>

<h3>Installing all dependencies for a project</h3>
<p>When uploading a project to GIThub, we don't need to upload the node_modules folder. All we have to do is to upload
    the <i>package.json</i> file. Then, the people who download the project code, will run the command line <i>npm
        install</i> in that folder, and that it! All the dependencies listed on the packages.json file will be
    automatically downloaded for that folder</p>


<h2>Express</h2>
<p>Express.js, or simply Express, is a back end web application framework for Node.js, released as free and open-source
    software under the MIT License. It is designed for building web applications and APIs.[3] It has been called the de
    facto standard server framework for Node.js.</p>

<h3>Starting a server</h3>
<pre><code>
    const express = require('express');
    const app = express();

app.use(() => {
    console.log('WE GOT A NEW REQUEST!');
    res.send('Hello, this is a response'); 
    <span class="red">the send method is what is sent as a response to the browser; it accepts strings, objects (which will be converted to json) and html.</span>
})
<span class="red">app.use is what happens when the request is received</span>

app.listen(8080, () => {
    console.log("LISTENING ON PORT 8080")
})
<span class="red">this sets the port on localhost where the requests are being listened; to access the server, go to localhost:8080 on any browser (on your machine)</span>
</code></pre>

<h3>Express routing basics</h3>
<p>Until now, it doesn't matter if the user is requesting the '/' page or the '/cats' page, with app.use the server will
    always send the same response.</p>
<p>Using app.get, we are able to get the exact request, and respond according to what comes after the /.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        res.send('This is the home page!');
    });

    app.get('/cats', (req, res) => {
        res.send('MEOW!');
    });

    app.get('/dogs', (req, res) => {
        res.send('WOOF!');
    });

    app.listen(8080, () => {
        console.log("LISTENING ON PORT 8080")
    })
</code></pre>
<p>Besides 'get', there are other http verbs, like, 'post', 'put', 'delete', etc. Express will differentiate incoming
    request of different types.</p>
<pre><code>
    app.post('/cats', (req, res) => {
        res.send('POST REQUEST TO /cats!!! This is a response!')
    })
</code></pre>
<p>To respond with a customized error page or message to a unexistent request address, (ex: '/hdhebdhbwh'):</p>
<pre><code>
    app.get('*', (req, res) => {
        res.send(`I don't know that path!`);
    });
</code></pre>

<h3>Routing path parameters</h3>
<p>In order to designate a pattern in a route, we can use :</p>
<pre><code>
    <span class="red">for ex, all Reddit's subreddits begin with the pattern /r/something</span>
    app.get('/r/:subreddit', (req, res) => {
        res.send('This is a subreddit!')
    })
</code></pre>
<p><b>req.params</b> is an object that contains one key/value pair for each routed pattern that we defined. The key of
    that property will be the word that we wrote after
    the colon(:), the value of that property will be the actual word requested by the user.</p>
<pre><code>
    app.get('/r/:subreddit', (req, res) => {
        { subredditName } = req.params;
        res.send(`< h2>Browsing the ${subredditName} subreddit!< /h2>`)
    })

    app.get('/r/:subreddit/:postId', (req, res) => {
        { subredditName, postId } = req.params;
        res.send(`< h1>Viewing the post called ${postId} on the ${subredditName} subreddit!< /h1>`)
    })
</code></pre>

<h3>Query strings</h3>
<p><b>req.query</b> is an object that contains one key/value pair for each query string requested by the user. The key
    of that property will be the name of the html form in which the query is generated, the value of that property will
    be the actual word requested by the user.</p>
<pre><code>
    app.get('search', (req, res) => {
        const { q } = req.query;
        res.send(`< h1>Search results for ${q}< /h1>`)
    });
</code></pre>

<h3>Auto-restart server with Nodemon</h3>
<p>Nodemon is a NPM package that automatically restarts the server every time we change our code on that project.
    Otherwise we have to restart the server so that the changes take place.</p>


<h3>Templating</h3>
<p>Templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify.</p>
<p>For example, we could define a single "Search" template that displays all the results for a given search term. We
    don't know what the term is or how many results there are ahead of time. The webpage id created on the fly.</p>
<p>There are many template languages to do this job, for example, EJS (embedded JS), Handlebars, Jade, Pug, Nunjucks
    etc.</p>

<h4>Setting EJS</h4>
<p>We need to "tell" Express that our template language will be EJS. Then we have to install EJS dependency on the
    project.</p>
<p>After installing EJS as a dependency, we don't have to require on the js script. When we set the 'view engine' to
    'ejs', Express will automatically do it for us.</p>
<p>We have to create a folder called 'views' inside the project directory, because EJS will look for this folder. Inside
    that folder, we need to create a file called 'something.ejs'.</p>
<p>We use res.render instead of res.send to render a ejs webpage inside the app.get callback. Express will automatically
    look for it in the /views folder.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.set('view engine', 'ejs');

    app.get('/'. (req, res) => {
        res.render('home.ejs')
        <span class="red">.ejs is optional</span>
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>
<p>In order to avoid conflicts, it is good practice to update the location of the '/views' folder using 'path.join'. The
    final code will look like this:</p>
<pre><code>
    const express = require('express');
    const app = express();
    const path = require('path');

    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, '/views'));

    app.get('/'. (req, res) => {
        res.render('home')
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>

<h4>EJS syntax</h4>
<b>Tags:</b>
<ul>
    <li>
        <% Scriptlet tag, for control-flow, no output</li>
    <li>
        <%_ Whitespace Slurping Scriptlet tag, strips all whitespace before it</li>
    <li>
        <%= Outputs the value into the template (HTML escaped). Escaped: turns HTML into string.</li>
    <li>
        <%- Outputs the unescaped value into the template. Unescaped: treats HTML just like HTML.</li>
    <li>
        <%# Comment tag, no execution, no output %>
    </li>
    <li>
        <%% Outputs a literal '<%' </li>
    <li>%> Plain ending tag</li>
    <li>-%> Trim-mode ('newline slurp') tag, trims following newline</li>
    <li>_%> â€˜Whitespace Slurpingâ€™ ending tag, removes all whitespace after it
    </li>
</ul>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    res.render('random')
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> Your random number is: <%= Math.floor(Math.random() * 10) + 1 %>< /h1>
    < /body>
</code></pre>

<h4>Passing data to templates</h4>
<p>We usually don't run complex script on template views, instead what we can do is to run them in the js file, assign
    variables and call it in the ejs template view:</p>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    <b>const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand: num })</b>
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> <b> Your random number is: <%= rand %></b>< /h1>
    < /body>
</code></pre>

<h4>Conditionals in EJS</h4>
<p>The <% (without=) tag disposes logical code that won't be rendered. Following the random number script mentioned
        above:</p>
        <pre><code>
    <span class="red">on the template view (.ejs)</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        <% if(num%2 === 0){ %>
        < h2>That is an even number!< /h2>
        <% } else { %>
        < h2>That is an odd number!< /h2>  
        <% } %> 
    < /body>

    <span class="red">using ternary operator:</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        < h2> <%= num%2===0 ? 'That is an even number!' : 'That is an odd number!'  %>< /h2>  
    < /body>
</code></pre>

        <h4>Loops in EJS</h4>
        <pre><code>
    <span class="red">on index.js</span>
    app.get('/cats', (req, res) => {
        const cats = ['Blue', 'Rocket', 'Monty', 'Winston'];
        res.render('cats', { cats })
    })

    <span class="red">on cats.ejs</span>
    < body>
        < h1>All the cats< /h1>
        < ul>
            <% for(let cat of cats){ %>
            < li><%= cat %>< /li>
            <% } %>
        < /ul>
    < /body>
</code></pre>

        <h4>Serving static files in Express</h4>
        <p>To serve static files such as images, CSS files and JS files, use the <b>express.static</b> built-in
            middleware function in Express.</p>
        <pre><code>
    app.use(express.static('/public'));

    <span class="red">using path.join to avoid conflicts</span>
    app.use(express.static(path.join(__dirname, '/public')));
</code></pre>

        <h4>EJS Partials</h4>
        <p>When we want a part of HTML (eg, an entire head) on all pages, we can save a .ejs file containing that code
            and then <b>include</b> the partial on every single page. It is a convention to create a folder for
            partials.</p>
        <pre><code>
    <%- include('partials/head') %>
</code></pre>

        <h3>Defining RESTful Routes</h3>
        <p>A RESTful API is an architectural style for an application program interface (API) that uses HTTP requests to
            access and use data. That data can be used to GET, PUT, POST and DELETE data types, which refers to the
            reading, updating, creating and deleting of operations concerning resources.</p>

        <h4>GET / POST requests</h4>
        <style type="text/css">
            .tg {
                border-collapse: collapse;
                border-spacing: 0;
            }

            .tg td {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg th {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: normal;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg .tg-0lax {
                text-align: left;
                vertical-align: top
            }
        </style>
        <table class="tg">
            <thead>
                <tr>
                    <th class="tg-0lax">GET</th>
                    <th class="tg-0lax">POST</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="tg-0lax">used to retrieve information</td>
                    <td class="tg-0lax">used to post data to the server</td>
                </tr>
                <tr>
                    <td class="tg-0lax">data is sent via query string</td>
                    <td class="tg-0lax">data is sent via request body</td>
                </tr>
                <tr>
                    <td class="tg-0lax">information is plainly visible in the URL</td>
                    <td class="tg-0lax">data is NOT visible in the URL</td>
                </tr>
                <tr>
                    <td class="tg-0lax">limited amount of data can be sent (circa 2K characters)</td>
                    <td class="tg-0lax">can send any sort of data (JSON)</td>
                </tr>
                <tr>
                    <td class="tg-0lax">doesn't create side-effects on the server</td>
                    <td class="tg-0lax">creates side-effects on the server</td>
                </tr>
            </tbody>
        </table>

        <h4>Handling POST requests</h4>
        <pre><code>
            <span class="red">on HTML file</span>
        GET
        < form action="http://localhost:3000/tacos" method="get">
            < input type="text" name="meat">
            < input type="number" name="qty">
        < /form>
        POST
        < form action="http://localhost:3000/tacos" method="post">
            < input type="text" name="meat">
            < input type="number" name="qty">
        < /form>

        <span class="red">on the index.js</span>
        app.get('/tacos', (req, res) => {
            res.send("GET /tacos response")
        })
        app.post('/tacos', (req, res) => {
            res.send("POST /tacos response")
        })
    </code></pre>
        <p>Parsing the request body:</p>
        <p>Post requests' req object contain an object called <b>req.body</b>. This object must be parsed by a
            middleware in Express, so that we can have access to it.</p>
        <pre><code>
app.use(express.urlencoded({ extended: true }));
<span class="red">this one will parse req.body that came from an HTML form.</span>
<span class="red">app.use tells that everytime it is needed, this will be the way to parse these objects.</span>

app.use(express.json());
<span class="red">this one will parse req.body that came in the JSON format.</span>
    </code></pre>




        <script src="app.js"></script>

</html>