<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node etc.</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Node etc.</h1>
    <p>Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on a JavaScript
        Engine (i.e. V8 engine) and executes JavaScript code outside a web browser, which was designed to build scalable
        network applications. Node.js lets developers use JavaScript to write command line tools and for server-side
        scriptingâ€”running scripts server-side to produce dynamic web page content before the page is sent to the user's
        web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application
        development around a single programming language, rather than different languages for server-side and
        client-side scripts.</p>
</body>
<h3>Running .js files using Node</h3>
<p>On the terminal:</p>
<pre><code>
    node firstScript.js
    <span class="red">the JS file will run inside the terminal</span>
</code></pre>
<h3>Process</h3>
<p>The process object is a global that provides information about, and control over, the current Node.js process. As a
    global, it is always available to Node.js applications without using require().</p>
<p>We can compare process to the window object on a browser.</p>
<h3>process.argv</h3>
<p>The process.argv property returns an array containing the command line arguments passed when the Node.js process was
    launched. The first element will be process.execPath. The process.execPath property returns the absolute pathname of
    the executable that started the Node.js process: usually '/usr/local/bin/node'. The second element will be the path
    to the JavaScript file being executed. The remaining elements will be any additional command line arguments.</p>
<pre><code>
    node firstScript.js puppies chickens hello
    <span class="red">these 3 strings will be added to the argv array.</span>
</code></pre>
<p>process.argv returns an array, and can be accessed from the js file.</p>

<h3>File System Module (fs)</h3>
<p>The fs module enables interacting with the file system. </p>
<p>All file system operations have synchronous, callback, and promise-based forms.</p>
<p>Unlike the process object, the fs module must be required before being used in the script.</p>
<p>Example: creating a script that creates boilerplates files (index.html, style.css, app.js) for a new project.</p>
<pre><code>
on script:
const fs = require('fs'); <span class="red">requires fs module</span>
const folderName = process.argv[2] || 'Project'; <span class="red">accesses the argument that was provided by the user</span>
fs.mkdirSync(folderName); <span class="red">creates a folder with the name provided by the user</span>
fs.writeFileSync(`${folderName}/index.html`, '');
fs.writeFileSync(`${folderName}/style.css`, '');
fs.writeFileSync(`${folderName}/app.js`, '')
<span class="red">creates these 3 files inside that folder. The second argument is the content of that file and can be set to empty.</span>

async version:
fs.mkdir(`${folderName}`, { recursive: true }, (err) => {
    console.log('The folder is successfully created')
    if (err) console.log(err);
 })
fs.writeFile(`${folderName}/index.html`, 'I am the new file\'s content', (err) => {
    console.log('The HTML file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/style.css`, 'I am the new file\'s content', (err) => {
    console.log('The CSS file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/app.js`, 'I am the new file\'s content', (err) => {
    console.log('The JS file is successfully created')
    if (err) console.log(err)
 });
 
on the command line:
node boilerplate.js Portfolio
<span class="red">creates a folder called Portfolio with those 3 files inside of it.</span>
</code></pre>

<h3>Exporting modules using module.export</h3>
<p>In order to create our own modules, the first thing to do is to put the value inside of module.exports object in the
    module's file.</p>
<p>Then we have to require the module using require('./moduleName') inside the file where we want to use it.</p>
<pre><code>
    on the module:
    module.exports.sum = (x,y) => x + y;
    exports.sum = (x,y) => x + y;
    <span class="red">exports is a shortcut for module.exports</span>

    on the script using the model:
    require('./math');
    <span class="red">assuming that the module's file is called math.js</span>
</code></pre>

<h3>Requiring a directory</h3>
<p>When requiring an entire folder, node.js will look into index.js, which should be inside that folder.</p>
<p>A common pattern is to require all values into index.js and then export them all from there.</p>

<h2>NPM</h2>
<p>NPM is the largest library of packages, which are modules written by other people, all ready for anyone to use.</p>
<p>NPM is also a command line tool to easily install and manage those packages in our Node projects.</p>

<h3>Installing packages from NPM</h3>
<p>To install a package from NPM, the basic command is: npm install packageName . This command has a shortcut: npm i
    packageName .</p>
<p>The correct packageName can be found in the package's documentation on NPM website.</p>
<p>To globally install a package, just add -g</p>
<pre><code>
    npm i packageName -g 
</code></pre>
<p>The global installation will install the package on the root of the computer, so that every project that requires
    that package will have it available. If the global installation fails, use this line to change permission:</p>
<pre><code>
sudo chown -R $USER/usr/local/lib/node_modules
</code></pre>

<h3>The <i>package.json</i> file</h3>
<p>Before installing any package to a projects folder, we have to run <b>npm init</b>. This will create a package.json
    file in the root of that project. This file contains metadata of the packages used by that project. Everytime we
    install a new package on that folder, this file will automatically update the <b>dependencies</b> property.</p>

<h3>Installing all dependencies for a project</h3>
<p>When uploading a project to GIThub, we don't need to upload the node_modules folder. All we have to do is to upload
    the <i>package.json</i> file. Then, the people who download the project code, will run the command line <i>npm
        install</i> in that folder, and that it! All the dependencies listed on the packages.json file will be
    automatically downloaded for that folder</p>


<h2>Express</h2>
<p>Express.js, or simply Express, is a back end web application framework for Node.js, released as free and open-source
    software under the MIT License. It is designed for building web applications and APIs.[3] It has been called the de
    facto standard server framework for Node.js.</p>

<h3>Starting a server</h3>
<pre><code>
    const express = require('express');
    const app = express();

app.use(() => {
    console.log('WE GOT A NEW REQUEST!');
    res.send('Hello, this is a response'); 
    <span class="red">the send method is what is sent as a response to the browser; it accepts strings, objects (which will be converted to json) and html.</span>
})
<span class="red">app.use is what happens when the request is received</span>

app.listen(8080, () => {
    console.log("LISTENING ON PORT 8080")
})
<span class="red">this sets the port on localhost where the requests are being listened; to access the server, go to localhost:8080 on any browser (on your machine)</span>
</code></pre>

<h3>Express routing basics</h3>
<p>Until now, it doesn't matter if the user is requesting the '/' page or the '/cats' page, with app.use the server will
    always send the same response.</p>
<p>Using app.get, we are able to get the exact request, and respond according to what comes after the /.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        res.send('This is the home page!');
    });

    app.get('/cats', (req, res) => {
        res.send('MEOW!');
    });

    app.get('/dogs', (req, res) => {
        res.send('WOOF!');
    });

    app.listen(8080, () => {
        console.log("LISTENING ON PORT 8080")
    })
</code></pre>
<p>Besides 'get', there are other http verbs, like, 'post', 'put', 'delete', etc. Express will differentiate incoming
    request of different types.</p>
<pre><code>
    app.post('/cats', (req, res) => {
        res.send('POST REQUEST TO /cats!!! This is a response!')
    })
</code></pre>
<p>To respond with a customized error page or message to a unexistent request address, (ex: '/hdhebdhbwh'):</p>
<pre><code>
    app.get('*', (req, res) => {
        res.send(`I don't know that path!`);
    });
</code></pre>

<h3>Routing path parameters</h3>
<p>In order to designate a pattern in a route, we can use :</p>
<pre><code>
    <span class="red">for ex, all Reddit's subreddits begin with the pattern /r/something</span>
    app.get('/r/:subreddit', (req, res) => {
        res.send('This is a subreddit!')
    })
</code></pre>
<p><b>req.params</b> is an object that contains one key/value pair for each routed pattern that we defined. The key of
    that property will be the word that we wrote after
    the colon(:), the value of that property will be the actual word requested by the user.</p>
<pre><code>
    app.get('/r/:subreddit', (req, res) => {
        { subredditName } = req.params;
        res.send(`< h2>Browsing the ${subredditName} subreddit!< /h2>`)
    })

    app.get('/r/:subreddit/:postId', (req, res) => {
        { subredditName, postId } = req.params;
        res.send(`< h1>Viewing the post called ${postId} on the ${subredditName} subreddit!< /h1>`)
    })
</code></pre>

<h3>Query strings</h3>
<p><b>req.query</b> is an object that contains one key/value pair for each query string requested by the user. The key
    of that property will be the name of the html form in which the query is generated, the value of that property will
    be the actual word requested by the user.</p>
<pre><code>
    app.get('search', (req, res) => {
        const { q } = req.query;
        res.send(`< h1>Search results for ${q}< /h1>`)
    });
</code></pre>

<h3>Auto-restart server with Nodemon</h3>
<p>Nodemon is a NPM package that automatically restarts the server every time we change our code on that project.
    Otherwise we have to restart the server so that the changes take place.</p>


<h3>Templating</h3>
<p>Templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify.</p>
<p>For example, we could define a single "Search" template that displays all the results for a given search term. We
    don't know what the term is or how many results there are ahead of time. The webpage id created on the fly.</p>
<p>There are many template languages to do this job, for example, EJS (embedded JS), Handlebars, Jade, Pug, Nunjucks
    etc.</p>

<h4>Setting EJS</h4>
<p>We need to "tell" Express that our template language will be EJS. Then we have to install EJS dependency on the
    project.</p>
<p>After installing EJS as a dependency, we don't have to require on the js script. When we set the 'view engine' to
    'ejs', Express will automatically do it for us.</p>
<p>We have to create a folder called 'views' inside the project directory, because EJS will look for this folder. Inside
    that folder, we need to create a file called 'something.ejs'.</p>
<p>We use res.render instead of res.send to render a ejs webpage inside the app.get callback. Express will automatically
    look for it in the /views folder.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.set('view engine', 'ejs');

    app.get('/'. (req, res) => {
        res.render('home.ejs')
        <span class="red">.ejs is optional</span>
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>
<p>In order to avoid conflicts, it is good practice to update the location of the '/views' folder using 'path.join'. The
    final code will look like this:</p>
<pre><code>
    const express = require('express');
    const app = express();
    const path = require('path');

    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, '/views'));

    app.get('/'. (req, res) => {
        res.render('home')
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>

<h4>EJS syntax</h4>
<b>Tags:</b>
<ul>
    <li>
        <% Scriptlet tag, for control-flow, no output</li>
    <li>
        <%_ Whitespace Slurping Scriptlet tag, strips all whitespace before it</li>
    <li>
        <%= Outputs the value into the template (HTML escaped). Escaped: turns HTML into string.</li>
    <li>
        <%- Outputs the unescaped value into the template. Unescaped: treats HTML just like HTML.</li>
    <li>
        <%# Comment tag, no execution, no output %>
    </li>
    <li>
        <%% Outputs a literal '<%' </li>
    <li>%> Plain ending tag</li>
    <li>-%> Trim-mode ('newline slurp') tag, trims following newline</li>
    <li>_%> â€˜Whitespace Slurpingâ€™ ending tag, removes all whitespace after it
    </li>
</ul>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    res.render('random')
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> Your random number is: <%= Math.floor(Math.random() * 10) + 1 %>< /h1>
    < /body>
</code></pre>

<h4>Passing data to templates</h4>
<p>We usually don't run complex script on template views, instead what we can do is to run them in the js file, assign
    variables and call it in the ejs template view:</p>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    <b>const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand: num })</b>
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> <b> Your random number is: <%= rand %></b>< /h1>
    < /body>
</code></pre>

<h4>Conditionals in EJS</h4>
<p>The <% (without=) tag disposes logical code that won't be rendered. Following the random number script mentioned
        above:</p>
        <pre><code>
    <span class="red">on the template view (.ejs)</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        <% if(num%2 === 0){ %>
        < h2>That is an even number!< /h2>
        <% } else { %>
        < h2>That is an odd number!< /h2>  
        <% } %> 
    < /body>

    <span class="red">using ternary operator:</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        < h2> <%= num%2===0 ? 'That is an even number!' : 'That is an odd number!'  %>< /h2>  
    < /body>
</code></pre>

        <h4>Loops in EJS</h4>
        <pre><code>
    <span class="red">on index.js</span>
    app.get('/cats', (req, res) => {
        const cats = ['Blue', 'Rocket', 'Monty', 'Winston'];
        res.render('cats', { cats })
    })

    <span class="red">on cats.ejs</span>
    < body>
        < h1>All the cats< /h1>
        < ul>
            <% for(let cat of cats){ %>
            < li><%= cat %>< /li>
            <% } %>
        < /ul>
    < /body>
</code></pre>

        <h4>Serving static files in Express</h4>
        <p>To serve static files such as images, CSS files and JS files, use the <b>express.static</b> built-in
            middleware function in Express.</p>
        <pre><code>
    app.use(express.static('/public'));

    <span class="red">using path.join to avoid conflicts</span>
    app.use(express.static(path.join(__dirname, '/public')));
</code></pre>

        <h4>EJS Partials</h4>
        <p>When we want a part of HTML (eg, an entire head) on all pages, we can save a .ejs file containing that code
            and then <b>include</b> the partial on every single page. It is a convention to create a folder for
            partials.</p>
        <pre><code>
<%- include('partials/head') %>
</code></pre>

        <h3>Defining RESTful Routes</h3>
        <p>A RESTful API is an architectural style for an application program interface (API) that uses HTTP requests to
            access and use data. That data can be used to GET, PUT, POST and DELETE data types, which refers to the
            reading, updating, creating and deleting of operations concerning resources.</p>

        <h4>GET / POST requests</h4>
        <style type="text/css">
            .tg {
                border-collapse: collapse;
                border-spacing: 0;
            }

            .tg td {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg th {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: normal;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg .tg-0lax {
                text-align: left;
                vertical-align: top
            }
        </style>
        <table class="tg">
            <thead>
                <tr>
                    <th class="tg-0lax">GET</th>
                    <th class="tg-0lax">POST</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="tg-0lax">used to retrieve information</td>
                    <td class="tg-0lax">used to post data to the server</td>
                </tr>
                <tr>
                    <td class="tg-0lax">data is sent via query string</td>
                    <td class="tg-0lax">data is sent via request body</td>
                </tr>
                <tr>
                    <td class="tg-0lax">information is plainly visible in the URL</td>
                    <td class="tg-0lax">data is NOT visible in the URL</td>
                </tr>
                <tr>
                    <td class="tg-0lax">limited amount of data can be sent (circa 2K characters)</td>
                    <td class="tg-0lax">can send any sort of data (JSON)</td>
                </tr>
                <tr>
                    <td class="tg-0lax">doesn't create side-effects on the server</td>
                    <td class="tg-0lax">creates side-effects on the server</td>
                </tr>
            </tbody>
        </table>

        <h4>Handling POST requests</h4>
        <pre><code>
<span class="red">on HTML file</span>
GET
< form action="http://localhost:3000/tacos" method="get">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>
POST
< form action="http://localhost:3000/tacos" method="post">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>

<span class="red">on the index.js</span>
app.get('/tacos', (req, res) => {
res.send("GET /tacos response")
})
app.post('/tacos', (req, res) => {
res.send("POST /tacos response")
})
</code></pre>
        <p>Parsing the request body:</p>
        <p>Post requests' req object contain an object called <b>req.body</b>. This object must be parsed by a
            middleware in Express, so that we can have access to it.</p>
        <pre><code>
app.use(express.urlencoded({ extended: true }));
<span class="red">this one will parse req.body that came from an HTML form.</span>
<span class="red">app.use tells that everytime it is needed, this will be the way to parse these objects.</span>

app.use(express.json());
<span class="red">this one will parse req.body that came in the JSON format.</span>
</code></pre>
        <p> What is Middleware? It is those methods/functions/operations that are called BETWEEN processing the Request
            and sending the Response in your application method.</p>

        <p> When talking about express.json() and express.urlencoded() think specifically about POST requests (i.e. the
            .post request object) and PUT Requests (i.e. the .put request object)
        </p>
        <p>
            You DO NOT NEED express.json() and express.urlencoded() for GET Requests or DELETE Requests.
        </p>
        <p>
            You NEED express.json() and express.urlencoded() for POST and PUT requests, because in both these requests
            you are sending data (in the form of some data object) to the server and you are asking the server to accept
            or store that data (object), which is enclosed in the body (i.e. req.body) of that (POST or PUT) Request
        </p>
        <p>
            Express provides you with middleware to deal with the (incoming) data (object) in the body of the request.
        </p>
        <p>
            a. express.json() is a method inbuilt in express to recognize the incoming Request Object as a JSON Object.
            This method is called as a middleware in your application using the code: app.use(express.json());
        </p>
        <p>
            b. express.urlencoded() is a method inbuilt in express to recognize the incoming Request Object as strings
            or arrays. This method is called as a middleware in your application using the code:
            app.use(express.urlencoded());
        </p>
        <p>
            ALTERNATIVELY, I recommend using body-parser (it is an NPM package) to do the same thing. It is developed by
            the same peeps who built express and is designed to work with express. body-parser used to be part of
            express. Think of body-parser specifically for POST Requests (i.e. the .post request object) and/or PUT
            Requests (i.e. the .put request object).
        </p>
        <p>
            Using body-parser you can do:
        </p>
        <pre><code>
<span class="red">calling body-parser to handle the Request Object from POST requests</span>
const bodyParser = require('body-parser');
<span class="red">parse application/json, basically parse incoming Request Object as a JSON Object </span>
app.use(bodyParser.json());
<span class="red">parse application/x-www-form-urlencoded, basically can only parse incoming Request Object if strings or arrays</span>
app.use(bodyParser.urlencoded({ extended: false }));
<span class="red">combines the 2 above, then you can parse incoming Request Object if object, with nested objects, or generally any type.</span>
app.use(bodyParser.urlencoded({ extended: true }));
</code></pre>

        <h4>Into to REST</h4>
        <p>What is REST? Representational State Transfer. Also called RESTful.</p>
        <p>REST is an "architectural" style for distributed hypermedia systems. It's basically a set of guidelines for
            how a client + server should communicate and perform CRUD (Create Read Update Delete.Destroy) operations on
            a given resource.</p>
        <p>The main idea of REST is treating data on the server-side as resources that can be CRUDed.</p>
        <p>The most common way of approaching REST is in formatting the URLs and HTTP verbs in your applications.</p>
        <p>Architectural pattern:</p>
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Path</th>
                    <th>Verb</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>index</td>
                    <td>/comments</td>
                    <td>GET</td>
                    <td>Display all comments</td>
                </tr>
                <tr>
                    <td>new</td>
                    <td>/comments/new</td>
                    <td>GET</td>
                    <td>Form to create new comment</td>
                </tr>
                <tr>
                    <td>create</td>
                    <td>/comments</td>
                    <td>POST</td>
                    <td>Creates new comment on server</td>
                </tr>
                <tr>
                    <td>show</td>
                    <td>/comments/:id</td>
                    <td>GET</td>
                    <td>Details for one specific comment</td>
                </tr>
                <tr>
                    <td>edit</td>
                    <td>/comments/:id/edit</td>
                    <td>GET</td>
                    <td>Form to edit specific comment</td>
                </tr>
                <tr>
                    <td>update</td>
                    <td>/comments/:id</td>
                    <td>PATCH</td>
                    <td>Updates specific comment on server</td>
                </tr>
                <tr>
                    <td>destroy</td>
                    <td>/comments/:id</td>
                    <td>DELETE</td>
                    <td>Deletes specific item on server</td>
                </tr>
            </tbody>
        </table>
        <h4>Setting up a REST</h4>
        <pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

const comments = [
    {
        id: 1,
        username: 'Todd',
        comment: 'lol that is sooo funny'
    },
    {
        id: 2,
        username: 'Skyler',
        comment: 'I like to go birdwatching with my dog'
    },
    {
        id: 3,
        username: 'Sk8erBoi',
        comment: 'Plz delete your account, Todd'
    },
    {
        id: 4,
        username: 'onlysayswoof',
        comment: 'woof woof woof'
    }
]

app.get('/comments', (req, res) => {
    res.render('comments/index', { comments })
})
<span class="red">the comments array is being passed through the render function, so that render can "use" the data in this array to create the page</span>

app.get('/tacos', (req, res) => {
    res.send("GET /tacos response")
})

app.post('/tacos', (req, res) => {
    const { meat, qty } = req.body;
    res.send(`OK, here are your ${qty} ${meat} tacos`)
})

app.listen(3000, () => {
    console.log('ON PORT 3000!')
})

<span class="red">on views/comments/index.ejs</span>
< h1>Comments< /h1>
< ul>
<% for(let c of comments){ %>
< li><%=c.comment%> - < b><%= c.username%>< /b>< /li>
<% }%>
< /ul>
</code></pre>

        <h4>RESTful comments new</h4>
        <p>Usually we display (GET) a form for the user to fill, then we submit (POST) the new comment to the server.
        </p>
        <pre><code>
            <span class="red">on index.js</span>
            app.get('/comments/new', (req, res) => {
                res.render('comments/new')
            })

            <span class="red">on new.ejs</span>
            < h1>Make a new comment< /h1>
            < form action="/comments" method="post">
                < section>
                    < label for="username">Enter username:< /label>
                    < input type="text" id="username" name="username">
                < /section>
                < section>
                    < label for="comment">Comment text:< /label>
                    < textarea name="comment" id="comment" cols="30" rows="5">< /textarea>
                    < /section>
                < button>Submit< /button>
            < /form>

            <span class="red">on index.js again</span>
            app.post('/comments', (req, res) => {
                <span class="red">deconstruct req.body object:</span>
                const { username, comment } = req.body;
                <span class="red">push the new comment as an object to the comments array:</span>
                comments.push({ username, comment });
                <span class="red">redirect to the /comments page to see all comments including the new one:</span>
                res.redirect('/comments');
            }
        </code></pre>

        <h4>RESTful comments show</h4>
        <p>To show, edit or delete specific items, we have to point to the items's unique id.</p>
        <pre><code>
            app.get('/comments/:id', (req, res) => {
                <span class="red">destructure req.params object to obtain the requested id:</span>
                const { id } = req.params;
                <span class="red">"find" the requested comments in the comments array (we have to transform the string in a number by using +id or parseInt(id)):</span>
                const comment = comments.find(c => c.id === +id);
                <span class="red">render page with the comment passed through:</span>
                res.render('comments/show', { comment });
            })

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username%>< /h2>
            < a href="comments">Back to all comments< /a>
        </code></pre>

        <h4>Generating random ids with UUID</h4>
        <p>In order to generate unique ids, we can make use of an NPM dependency called UUID.</p>
        <p>After install it using <b>npm i uuid</b>, we have to require it on the script. Here we will use version 4's
            ids (each version provides a different id format). The id created by UUID is a STRING.</p>
        <pre><code>
            <span class="red">on index.js</span>
            const { v4: uuid } = require('uuid');

            const comments = [
                {
                    id: uuid(),
                    username: 'Todd',
                    comment: 'lol that is sooo funny'
                },
                {
                    id: uuid(),
                    username: 'Skyler',
                    comment: 'I like to go birdwatching with my dog'
                },
                {
                    id: uuid(),
                    username: 'Sk8erBoi',
                    comment: 'Plz delete your account, Todd'
                },
                {
                    id: uuid(),
                    username: 'onlysayswoof',
                    comment: 'woof woof woof'
                }
            ]

            <span class="red">also we have to provide an unique id for each new comment:</span>
            app.post('/comments', (req, res) => {
                const { username, comment } = req.body;
                comments.push({ username, comment, id: uuid() });
                res.redirect('comments');
            })

        </code></pre>

        <h4>RESTful requests update</h4>
        <p>To update (edit, modify) an existing item, we can use the verbs PUT, PATCH or POST.</p>
        <p>PUT is used to replace all current representations of the target resource with the payload.</p>
        <p>PATCH is used to apply partial modifications to a resource.</p>
        <p>POST is used to create a completely new resource item.</p>
        <pre><code>
            app.patch('comments/:id', (req, res) => {
                <span class="red">deconstruct id from the req.params object:</span>
                const { id } = req.params;
                <span class="red">"find" that specific comment in our comments array:</span>
                const foundComment = comments.find(c => c.id === id)
                <span class="red">(because we're using UUID, and the ID generated by UUID is a string, we don't need to transform it into a number)</span>
                <span class="red">obtaining the new comment from the req.body object (we could also desctructure/rename it):</span>
                const newCommentText = req.body.comment;
                <span class="red">redirect to index.ejs:</span>
                res.redirect('/comments');
            })
        </code></pre>







        <script src="app.js"></script>

</html>