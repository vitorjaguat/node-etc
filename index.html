<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node etc.</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Node etc.</h1>
    <p>Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on a JavaScript
        Engine (i.e. V8 engine) and executes JavaScript code outside a web browser, which was designed to build scalable
        network applications. Node.js lets developers use JavaScript to write command line tools and for server-side
        scripting—running scripts server-side to produce dynamic web page content before the page is sent to the user's
        web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application
        development around a single programming language, rather than different languages for server-side and
        client-side scripts.</p>
</body>
<h3>Running .js files using Node</h3>
<p>On the terminal:</p>
<pre><code>
    node firstScript.js
    <span class="red">the JS file will run inside the terminal</span>
</code></pre>
<h3>Process</h3>
<p>The process object is a global that provides information about, and control over, the current Node.js process. As a
    global, it is always available to Node.js applications without using require().</p>
<p>We can compare process to the window object on a browser.</p>
<h3>process.argv</h3>
<p>The process.argv property returns an array containing the command line arguments passed when the Node.js process was
    launched. The first element will be process.execPath. The process.execPath property returns the absolute pathname of
    the executable that started the Node.js process: usually '/usr/local/bin/node'. The second element will be the path
    to the JavaScript file being executed. The remaining elements will be any additional command line arguments.</p>
<pre><code>
    node firstScript.js puppies chickens hello
    <span class="red">these 3 strings will be added to the argv array.</span>
</code></pre>
<p>process.argv returns an array, and can be accessed from the js file.</p>

<h3>File System Module (fs)</h3>
<p>The fs module enables interacting with the file system. </p>
<p>All file system operations have synchronous, callback, and promise-based forms.</p>
<p>Unlike the process object, the fs module must be required before being used in the script.</p>
<p>Example: creating a script that creates boilerplates files (index.html, style.css, app.js) for a new project.</p>
<pre><code>
on script:
const fs = require('fs'); <span class="red">requires fs module</span>
const folderName = process.argv[2] || 'Project'; <span class="red">accesses the argument that was provided by the user</span>
fs.mkdirSync(folderName); <span class="red">creates a folder with the name provided by the user</span>
fs.writeFileSync(`${folderName}/index.html`, '');
fs.writeFileSync(`${folderName}/style.css`, '');
fs.writeFileSync(`${folderName}/app.js`, '')
<span class="red">creates these 3 files inside that folder. The second argument is the content of that file and can be set to empty.</span>

async version:
fs.mkdir(`${folderName}`, { recursive: true }, (err) => {
    console.log('The folder is successfully created')
    if (err) console.log(err);
 })
fs.writeFile(`${folderName}/index.html`, 'I am the new file\'s content', (err) => {
    console.log('The HTML file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/style.css`, 'I am the new file\'s content', (err) => {
    console.log('The CSS file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/app.js`, 'I am the new file\'s content', (err) => {
    console.log('The JS file is successfully created')
    if (err) console.log(err)
 });
 
on the command line:
node boilerplate.js Portfolio
<span class="red">creates a folder called Portfolio with those 3 files inside of it.</span>
</code></pre>

<h3>Exporting modules using module.export</h3>
<p>In order to create our own modules, the first thing to do is to put the value inside of module.exports object in the
    module's file.</p>
<p>Then we have to require the module using require('./moduleName') inside the file where we want to use it.</p>
<pre><code>
    on the module:
    module.exports.sum = (x,y) => x + y;
    exports.sum = (x,y) => x + y;
    <span class="red">exports is a shortcut for module.exports</span>

    on the script using the model:
    require('./math');
    <span class="red">assuming that the module's file is called math.js</span>
</code></pre>

<h3>Requiring a directory</h3>
<p>When requiring an entire folder, node.js will look into index.js, which should be inside that folder.</p>
<p>A common pattern is to require all values into index.js and then export them all from there.</p>

<h2>NPM</h2>
<p>NPM is the largest library of packages, which are modules written by other people, all ready for anyone to use.</p>
<p>NPM is also a command line tool to easily install and manage those packages in our Node projects.</p>

<h3>Installing packages from NPM</h3>
<p>To install a package from NPM, the basic command is: npm install packageName . This command has a shortcut: npm i
    packageName .</p>
<p>The correct packageName can be found in the package's documentation on NPM website.</p>
<p>To globally install a package, just add -g</p>
<pre><code>
    npm i packageName -g 
</code></pre>
<p>The global installation will install the package on the root of the computer, so that every project that requires
    that package will have it available. If the global installation fails, use this line to change permission:</p>
<pre><code>
sudo chown -R $USER/usr/local/lib/node_modules
</code></pre>

<h3>The <i>package.json</i> file</h3>
<p>Before installing any package to a projects folder, we have to run <b>npm init</b>. This will create a package.json
    file in the root of that project. This file contains metadata of the packages used by that project. Everytime we
    install a new package on that folder, this file will automatically update the <b>dependencies</b> property.</p>

<h3>Installing all dependencies for a project</h3>
<p>When uploading a project to GIThub, we don't need to upload the node_modules folder. All we have to do is to upload
    the <i>package.json</i> file. Then, the people who download the project code, will run the command line <i>npm
        install</i> in that folder, and that it! All the dependencies listed on the packages.json file will be
    automatically downloaded for that folder</p>


<h2>Express</h2>
<p>Express.js, or simply Express, is a back end web application framework for Node.js, released as free and open-source
    software under the MIT License. It is designed for building web applications and APIs.[3] It has been called the de
    facto standard server framework for Node.js.</p>

<h3>Starting a server</h3>
<pre><code>
    const express = require('express');
    const app = express();

app.use(() => {
    console.log('WE GOT A NEW REQUEST!');
    res.send('Hello, this is a response'); 
    <span class="red">the send method is what is sent as a response to the browser; it accepts strings, objects (which will be converted to json) and html.</span>
})
<span class="red">app.use is what happens when the request is received</span>

app.listen(8080, () => {
    console.log("LISTENING ON PORT 8080")
})
<span class="red">this sets the port on localhost where the requests are being listened; to access the server, go to localhost:8080 on any browser (on your machine)</span>
</code></pre>

<h3>Express routing basics</h3>
<p>Until now, it doesn't matter if the user is requesting the '/' page or the '/cats' page, with app.use the server will
    always send the same response.</p>
<p>Using app.get, we are able to get the exact request, and respond according to what comes after the /.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        res.send('This is the home page!');
    });

    app.get('/cats', (req, res) => {
        res.send('MEOW!');
    });

    app.get('/dogs', (req, res) => {
        res.send('WOOF!');
    });

    app.listen(8080, () => {
        console.log("LISTENING ON PORT 8080")
    })
</code></pre>
<p>Besides 'get', there are other http verbs, like, 'post', 'put', 'delete', etc. Express will differentiate incoming
    request of different types.</p>
<pre><code>
    app.post('/cats', (req, res) => {
        res.send('POST REQUEST TO /cats!!! This is a response!')
    })
</code></pre>
<p>To respond with a customized error page or message to a unexistent request address, (ex: '/hdhebdhbwh'):</p>
<pre><code>
    app.get('*', (req, res) => {
        res.send(`I don't know that path!`);
    });
</code></pre>

<h3>Routing path parameters</h3>
<p>In order to designate a pattern in a route, we can use :</p>
<pre><code>
    <span class="red">for ex, all Reddit's subreddits begin with the pattern /r/something</span>
    app.get('/r/:subreddit', (req, res) => {
        res.send('This is a subreddit!')
    })
</code></pre>
<p><b>req.params</b> is an object that contains one key/value pair for each routed pattern that we defined. The key of
    that property will be the word that we wrote after
    the colon(:), the value of that property will be the actual word requested by the user.</p>
<pre><code>
    app.get('/r/:subreddit', (req, res) => {
        { subredditName } = req.params;
        res.send(`< h2>Browsing the ${subredditName} subreddit!< /h2>`)
    })

    app.get('/r/:subreddit/:postId', (req, res) => {
        { subredditName, postId } = req.params;
        res.send(`< h1>Viewing the post called ${postId} on the ${subredditName} subreddit!< /h1>`)
    })
</code></pre>

<h3>Query strings</h3>
<p><b>req.query</b> is an object that contains one key/value pair for each query string requested by the user. The key
    of that property will be the name of the html form in which the query is generated, the value of that property will
    be the actual word requested by the user.</p>
<pre><code>
    app.get('search', (req, res) => {
        const { q } = req.query;
        res.send(`< h1>Search results for ${q}< /h1>`)
    });
</code></pre>

<h3>Auto-restart server with Nodemon</h3>
<p>Nodemon is a NPM package that automatically restarts the server every time we change our code on that project.
    Otherwise we have to restart the server so that the changes take place.</p>


<h3>Templating</h3>
<p>Templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify.</p>
<p>For example, we could define a single "Search" template that displays all the results for a given search term. We
    don't know what the term is or how many results there are ahead of time. The webpage id created on the fly.</p>
<p>There are many template languages to do this job, for example, EJS (embedded JS), Handlebars, Jade, Pug, Nunjucks
    etc.</p>

<h4>Setting EJS</h4>
<p>We need to "tell" Express that our template language will be EJS. Then we have to install EJS dependency on the
    project.</p>
<p>After installing EJS as a dependency, we don't have to require on the js script. When we set the 'view engine' to
    'ejs', Express will automatically do it for us.</p>
<p>We have to create a folder called 'views' inside the project directory, because EJS will look for this folder. Inside
    that folder, we need to create a file called 'something.ejs'.</p>
<p>We use res.render instead of res.send to render a ejs webpage inside the app.get callback. Express will automatically
    look for it in the /views folder.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.set('view engine', 'ejs');

    app.get('/'. (req, res) => {
        res.render('home.ejs')
        <span class="red">.ejs is optional</span>
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>
<p>In order to avoid conflicts, it is good practice to update the location of the '/views' folder using 'path.join'. The
    final code will look like this:</p>
<pre><code>
    const express = require('express');
    const app = express();
    const path = require('path');

    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, '/views'));

    app.get('/'. (req, res) => {
        res.render('home')
    });

    app.listen(3000, () => {
        console.log('Listening on port 3000')
    });
</code></pre>

<h4>EJS syntax</h4>
<b>Tags:</b>
<ul>
    <li>
        <% Scriptlet tag, for control-flow, no output</li>
    <li>
        <%_ Whitespace Slurping Scriptlet tag, strips all whitespace before it</li>
    <li>
        <%= Outputs the value into the template (HTML escaped). Escaped: turns HTML into string.</li>
    <li>
        <%- Outputs the unescaped value into the template. Unescaped: treats HTML just like HTML.</li>
    <li>
        <%# Comment tag, no execution, no output %>
    </li>
    <li>
        <%% Outputs a literal '<%' </li>
    <li>%> Plain ending tag</li>
    <li>-%> Trim-mode ('newline slurp') tag, trims following newline</li>
    <li>_%> ‘Whitespace Slurping’ ending tag, removes all whitespace after it
    </li>
</ul>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    res.render('random')
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> Your random number is: <%= Math.floor(Math.random() * 10) + 1 %>< /h1>
    < /body>
</code></pre>

<h4>Passing data to templates</h4>
<p>We usually don't run complex script on template views, instead what we can do is to run them in the js file, assign
    variables and call it in the ejs template view:</p>
<pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'));

app.get('/', (req, res) =>{
    res.render('home')
})

app.get('/rand', (req, res) => {
    <b>const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand: num })</b>
})

app.listen(3000, () => {
    console.log("LISTENING ON PORT 3000")
})

<span class="red">on rand.ejs</span>
< body>
< h1> <b> Your random number is: <%= rand %></b>< /h1>
    < /body>
</code></pre>

<h4>Conditionals in EJS</h4>
<p>The <% (without=) tag disposes logical code that won't be rendered. Following the random number script mentioned
        above:</p>
        <pre><code>
    <span class="red">on the template view (.ejs)</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        <% if(num%2 === 0){ %>
        < h2>That is an even number!< /h2>
        <% } else { %>
        < h2>That is an odd number!< /h2>  
        <% } %> 
    < /body>

    <span class="red">using ternary operator:</span>
    < body>
        < h1> Your random number is: <%= num %>< /h1>
        < h2> <%= num%2===0 ? 'That is an even number!' : 'That is an odd number!'  %>< /h2>  
    < /body>
</code></pre>

        <h4>Loops in EJS</h4>
        <pre><code>
    <span class="red">on index.js</span>
    app.get('/cats', (req, res) => {
        const cats = ['Blue', 'Rocket', 'Monty', 'Winston'];
        res.render('cats', { cats })
    })

    <span class="red">on cats.ejs</span>
    < body>
        < h1>All the cats< /h1>
        < ul>
            <% for(let cat of cats){ %>
            < li><%= cat %>< /li>
            <% } %>
        < /ul>
    < /body>
</code></pre>

<h4>Serving static files in Express</h4>
<p>To serve static files such as images, CSS files and JS files, use the <b>express.static</b> built-in middleware function in Express.</p>
<p>Com o Express, é possível entregar os arquivos estáticos de forma separada no sistema. E isso é importante porque você consegue dizer para o servidor, exatamente quais arquivos não precisam de um processamento, mas sim que ele só seja entregue para uso. Dessa forma o servidor vai entender que aquele arquivo, não requer nenhum tipo de lógica ou processamento para ser entregue, ele simplesmente é mostrado na tela para o usuário. Os arquivos estáticos podem ser fotos, arquivos, folhas de estilo css, arquivos javascript, arquivos somente com HTML e entre outros.</p>
<p>O express.static é um middleware que é integrado ao express e que permite indicar onde estarão os arquivos estáticos a serem carregados. É possível fazer a configuração somente uma vez, e normalmente é feita dentro do arquivo principal do sistema, que pode ser o server.js, main.js, index.js, depende de como configurou seu sistema. Essa configuração indica o diretório do servidor no qual estão os arquivos estáticos, com isso, sempre que no código tiver referência a uma imagem por exemplo, o servidor sabe que precisa ir buscar para o diretório que foi configurado.
Normalmente é configurado só um diretório e com o nome 'public'.</p>

<pre><code>
    app.use(express.static('/public'));

    <span class="red">using path.join to avoid conflicts</span>
    app.use(express.static(path.join(__dirname, '/public')));
</code></pre>

        <h4>EJS Partials</h4>
        <p>When we want a part of HTML (eg, an entire head) on all pages, we can save a .ejs file containing that code
            and then <b>include</b> the partial on every single page. It is a convention to create a folder for
            partials.</p>
        <pre><code>
<%- include('partials/head') %>
</code></pre>

        <h3>Defining RESTful Routes</h3>
        <p>A RESTful API is an architectural style for an application program interface (API) that uses HTTP requests to
            access and use data. That data can be used to GET, PUT, POST and DELETE data types, which refers to the
            reading, updating, creating and deleting of operations concerning resources.</p>

        <h4>GET / POST requests</h4>
        <style type="text/css">
            .tg {
                border-collapse: collapse;
                border-spacing: 0;
            }

            .tg td {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg th {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: normal;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg .tg-0lax {
                text-align: left;
                vertical-align: top
            }
        </style>
        <table class="tg">
            <thead>
                <tr>
                    <th class="tg-0lax">GET</th>
                    <th class="tg-0lax">POST</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="tg-0lax">used to retrieve information</td>
                    <td class="tg-0lax">used to post data to the server</td>
                </tr>
                <tr>
                    <td class="tg-0lax">data is sent via query string</td>
                    <td class="tg-0lax">data is sent via request body</td>
                </tr>
                <tr>
                    <td class="tg-0lax">information is plainly visible in the URL</td>
                    <td class="tg-0lax">data is NOT visible in the URL</td>
                </tr>
                <tr>
                    <td class="tg-0lax">limited amount of data can be sent (circa 2K characters)</td>
                    <td class="tg-0lax">can send any sort of data (JSON)</td>
                </tr>
                <tr>
                    <td class="tg-0lax">doesn't create side-effects on the server</td>
                    <td class="tg-0lax">creates side-effects on the server</td>
                </tr>
            </tbody>
        </table>

        <h4>Handling POST requests</h4>
        <pre><code>
<span class="red">on HTML file</span>
GET
< form action="http://localhost:3000/tacos" method="get">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>
POST
< form action="http://localhost:3000/tacos" method="post">
< input type="text" name="meat">
< input type="number" name="qty">
< /form>

<span class="red">on the index.js</span>
app.get('/tacos', (req, res) => {
res.send("GET /tacos response")
})
app.post('/tacos', (req, res) => {
res.send("POST /tacos response")
})
</code></pre>
        <p>Parsing the request body:</p>
        <p>Post requests' req object contain an object called <b>req.body</b>. This object must be parsed by a
            middleware in Express, so that we can have access to it.</p>
        <pre><code>
app.use(express.urlencoded({ extended: true }));
<span class="red">this one will parse req.body that came from an HTML form.</span>
<span class="red">app.use tells that everytime it is needed, this will be the way to parse these objects.</span>

app.use(express.json());
<span class="red">this one will parse req.body that came in the JSON format.</span>
</code></pre>
        <p> What is Middleware? It is those methods/functions/operations that are called BETWEEN processing the Request
            and sending the Response in your application method.</p>

        <p> When talking about express.json() and express.urlencoded() think specifically about POST requests (i.e. the
            .post request object) and PUT Requests (i.e. the .put request object)
        </p>
        <p>
            You DO NOT NEED express.json() and express.urlencoded() for GET Requests or DELETE Requests.
        </p>
        <p>
            You NEED express.json() and express.urlencoded() for POST and PUT requests, because in both these requests
            you are sending data (in the form of some data object) to the server and you are asking the server to accept
            or store that data (object), which is enclosed in the body (i.e. req.body) of that (POST or PUT) Request
        </p>
        <p>
            Express provides you with middleware to deal with the (incoming) data (object) in the body of the request.
        </p>
        <p>
            a. express.json() is a method inbuilt in express to recognize the incoming Request Object as a JSON Object.
            This method is called as a middleware in your application using the code: app.use(express.json());
        </p>
        <p>
            b. express.urlencoded() is a method inbuilt in express to recognize the incoming Request Object as strings
            or arrays. This method is called as a middleware in your application using the code:
            app.use(express.urlencoded());
        </p>
        <p>
            ALTERNATIVELY, I recommend using body-parser (it is an NPM package) to do the same thing. It is developed by
            the same peeps who built express and is designed to work with express. body-parser used to be part of
            express. Think of body-parser specifically for POST Requests (i.e. the .post request object) and/or PUT
            Requests (i.e. the .put request object).
        </p>
        <p>
            Using body-parser you can do:
        </p>
        <pre><code>
<span class="red">calling body-parser to handle the Request Object from POST requests</span>
const bodyParser = require('body-parser');
<span class="red">parse application/json, basically parse incoming Request Object as a JSON Object </span>
app.use(bodyParser.json());
<span class="red">parse application/x-www-form-urlencoded, basically can only parse incoming Request Object if strings or arrays</span>
app.use(bodyParser.urlencoded({ extended: false }));
<span class="red">combines the 2 above, then you can parse incoming Request Object if object, with nested objects, or generally any type.</span>
app.use(bodyParser.urlencoded({ extended: true }));
</code></pre>

        <h4>Into to REST</h4>
        <p>What is REST? Representational State Transfer. Also called RESTful.</p>
        <p>REST is an "architectural" style for distributed hypermedia systems. It's basically a set of guidelines for
            how a client + server should communicate and perform CRUD (Create Read Update Delete.Destroy) operations on
            a given resource.</p>
        <p>The main idea of REST is treating data on the server-side as resources that can be CRUDed.</p>
        <p>The most common way of approaching REST is in formatting the URLs and HTTP verbs in your applications.</p>
        <p>Architectural pattern:</p>
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Path</th>
                    <th>Verb</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>index</td>
                    <td>/comments</td>
                    <td>GET</td>
                    <td>Display all comments</td>
                </tr>
                <tr>
                    <td>new</td>
                    <td>/comments/new</td>
                    <td>GET</td>
                    <td>Form to create new comment</td>
                </tr>
                <tr>
                    <td>create</td>
                    <td>/comments</td>
                    <td>POST</td>
                    <td>Creates new comment on server</td>
                </tr>
                <tr>
                    <td>show</td>
                    <td>/comments/:id</td>
                    <td>GET</td>
                    <td>Details for one specific comment</td>
                </tr>
                <tr>
                    <td>edit</td>
                    <td>/comments/:id/edit</td>
                    <td>GET</td>
                    <td>Form to edit specific comment</td>
                </tr>
                <tr>
                    <td>update</td>
                    <td>/comments/:id</td>
                    <td>PATCH</td>
                    <td>Updates specific comment on server</td>
                </tr>
                <tr>
                    <td>destroy</td>
                    <td>/comments/:id</td>
                    <td>DELETE</td>
                    <td>Deletes specific item on server</td>
                </tr>
            </tbody>
        </table>
        <h4>Setting up a REST</h4>
        <pre><code>
<span class="red">on index.js</span>
const express = require('express');
const app = express();
const path = require('path');

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

const comments = [
    {
        id: 1,
        username: 'Todd',
        comment: 'lol that is sooo funny'
    },
    {
        id: 2,
        username: 'Skyler',
        comment: 'I like to go birdwatching with my dog'
    },
    {
        id: 3,
        username: 'Sk8erBoi',
        comment: 'Plz delete your account, Todd'
    },
    {
        id: 4,
        username: 'onlysayswoof',
        comment: 'woof woof woof'
    }
]

app.get('/comments', (req, res) => {
    res.render('comments/index', { comments })
})
<span class="red">the comments array is being passed through the render function, so that render can "use" the data in this array to create the page</span>

app.get('/tacos', (req, res) => {
    res.send("GET /tacos response")
})

app.post('/tacos', (req, res) => {
    const { meat, qty } = req.body;
    res.send(`OK, here are your ${qty} ${meat} tacos`)
})

app.listen(3000, () => {
    console.log('ON PORT 3000!')
})

<span class="red">on views/comments/index.ejs</span>
< h1>Comments< /h1>
< ul>
<% for(let c of comments){ %>
< li><%=c.comment%> - < b><%= c.username%>< /b>< /li>
<% }%>
< /ul>
</code></pre>

        <h4>RESTful comments new</h4>
        <p>Usually we display (GET) a form for the user to fill, then we submit (POST) the new comment to the server.
        </p>
        <pre><code>
            <span class="red">on index.js</span>
            app.get('/comments/new', (req, res) => {
                res.render('comments/new')
            })

            <span class="red">on new.ejs</span>
            < h1>Make a new comment< /h1>
            < form action="/comments" method="post">
                < section>
                    < label for="username">Enter username:< /label>
                    < input type="text" id="username" name="username">
                < /section>
                < section>
                    < label for="comment">Comment text:< /label>
                    < textarea name="comment" id="comment" cols="30" rows="5">< /textarea>
                    < /section>
                < button>Submit< /button>
            < /form>

            <span class="red">on index.js again</span>
            app.post('/comments', (req, res) => {
                <span class="red">deconstruct req.body object:</span>
                const { username, comment } = req.body;
                <span class="red">push the new comment as an object to the comments array:</span>
                comments.push({ username, comment });
                <span class="red">redirect to the /comments page to see all comments including the new one:</span>
                res.redirect('/comments');
            }
        </code></pre>

        <h4>RESTful comments show</h4>
        <p>To show, edit or delete specific items, we have to point to the items's unique id.</p>
        <pre><code>
            app.get('/comments/:id', (req, res) => {
                <span class="red">destructure req.params object to obtain the requested id:</span>
                const { id } = req.params;
                <span class="red">"find" the requested comments in the comments array (we have to transform the string in a number by using +id or parseInt(id)):</span>
                const comment = comments.find(c => c.id === +id);
                <span class="red">render page with the comment passed through:</span>
                res.render('comments/show', { comment });
            })

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username%>< /h2>
            < a href="comments">Back to all comments< /a>
        </code></pre>

        <h4>Generating random ids with UUID</h4>
        <p>In order to generate unique ids, we can make use of an NPM dependency called UUID.</p>
        <p>After install it using <b>npm i uuid</b>, we have to require it on the script. Here we will use version 4's
            ids (each version provides a different id format). The id created by UUID is a STRING.</p>
        <pre><code>
            <span class="red">on index.js</span>
            const { v4: uuid } = require('uuid');

            const comments = [
                {
                    id: uuid(),
                    username: 'Todd',
                    comment: 'lol that is sooo funny'
                },
                {
                    id: uuid(),
                    username: 'Skyler',
                    comment: 'I like to go birdwatching with my dog'
                },
                {
                    id: uuid(),
                    username: 'Sk8erBoi',
                    comment: 'Plz delete your account, Todd'
                },
                {
                    id: uuid(),
                    username: 'onlysayswoof',
                    comment: 'woof woof woof'
                }
            ]

            <span class="red">also we have to provide an unique id for each new comment:</span>
            app.post('/comments', (req, res) => {
                const { username, comment } = req.body;
                comments.push({ username, comment, id: uuid() });
                res.redirect('comments');
            })

        </code></pre>

        <h4>RESTful requests update</h4>
        <p>To update (edit, modify) an existing item, we can use the verbs PUT, PATCH or POST.</p>
        <p>PUT is used to replace all current representations of the target resource with the payload.</p>
        <p>PATCH is used to apply partial modifications to a resource.</p>
        <p>POST is used to create a completely new resource item.</p>
        <pre><code>
            app.patch('comments/:id', (req, res) => {
                <span class="red">deconstruct id from the req.params object:</span>
                const { id } = req.params;
                <span class="red">"find" that specific comment in our comments array:</span>
                const foundComment = comments.find(c => c.id === id)
                <span class="red">(because we're using UUID, and the ID generated by UUID is a string, we don't need to transform it into a number)</span>
                <span class="red">obtaining the new comment from the req.body object (we could also desctructure/rename it):</span>
                const newCommentText = req.body.comment;
                <span class="red">redirect to index.ejs:</span>
                res.redirect('/comments');
            })
        </code></pre>
        <p>The route in the server that will update (patch) the item is ready. Now we must create a form
            (comments/:id/edit) for the user to fill the new input data.</p>
        <pre><code>
            <span class="red">on index.js</span>
            app.get('comments/:id/edit', (req, res) => {
                const { id } = req.params;
                const comment = comments.find(c => c.id === id);
                res.render('comments/edit', { comment })
            })

            <span class="red">on edit.ejs</span>
            < h1>Edit< /h1>
            < form action="/comments/<%=comment.id%>">
                < textarea name="comment" id="" cols="30" rows="10">
                    <%= comment.comment %>
                    <span class="red">this will show the current text for the user to update as she wants</span>
                </ textarea>
                < button>Save< /button>
            < /form>

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username %>< /h2>
            < a href="/comments">Back to index< /a>
            < a href="/comments/<%=comments.id%>/edit">Edit comment< /a>
        </code></pre>
        <p>An HTML form does not support PATCH method, only supports GET and POST. So we have to install a dependency
            called 'method-override'.After installing, requiring and app.use ing this, we need to add to the form's
            action attribute: <b>?_method=PATCH</b>, and also define the method attribute as <b>"post"</b>.</p>
        <pre><code>
            <span class="red">on terminal</span>
            npm i method-override

            <span class="red">on index.js</span>
            const methodOverride = require('method-override');
            app.use(methodOverride('_method'));

            <span class="red">on edit.ejs</span>
            < h1>Edit< /h1>
            < form <b>method="post"</b> action="/comments/<%=comment.id%><b>?_method=PATCH</b>">
                < textarea name="comment" id="" cols="30" rows="10">
                    <%= comment.comment %>
                </ textarea>
                < button>Save< /button>
            < /form>
        </code></pre>

        <h4>RESTful comments delete</h4>
        <p>Same as PATCH, DELETE method is not supported as a method in HTML forms (they only accept GET or POST), so we
            have to use 'method-override' in order to "fake it".</p>
        <pre><code>
            <span class="red">on index.js</span>
            app.delete('/comments/:id', (req, res) => {
                const { id } = req.params;
                comments = comments.filter(c => c.id !== id);
                res.redirect('/comments');
            })

            <span class="red">on show.ejs</span>
            < h1>Comment id: <%= comment.id %>< /h1>
            < h2><%= comment.comment %> - <%= comment.username %>< /h2>
            < a href="/comments">Back to index< /a>
            < a href="/comments/<%=comments.id%>/edit">Edit comment< /a>
            < form method="post" action="/comments/<%=comment.id%>?_method=DELETE">
                < button>Delete< /button>
            < /form>
        </code></pre>

        <h2>MongoDB</h2>
        <p>According to Mongo's homepage, it is "the most popular database for modern applications". It is commonly used
            in combination with Node.</p>
        <p>Mongo is a document database, which we can use to store and receive complex data from.</p>
        <p>Why use a database, instead of just saving to a file?
        <ul>
            <li>Databases can handle large amounts of data efficiently and store ir compactly</li>
            <li>They provide tools for easy insertion, querying and uploading of data</li>
            <li>They generally offer security features and control over access to data</li>
            <li>They generally scale well</li>
        </ul>
</p>

<h4>SQL vs. NoSQL databases</h4>
<p>Structured Query Language (SQL) databases are relational databases. We pre-define a schema of tables before we insert
    anything. Ex.: MySQL, Postgres, SQLite, Oracle, Microsoft SQL Server.</p>
<p>No-SQL databases do not use SQL. There are many types of no-sql databases, inluding document, key-value and graph
    stores. Ex.: MongoDB, CouchDB, Neo4j, Cassandra, Redis.</p>

<h4>Why using Mongo?</h4>
<ul>
    <li>Mongo is very commonly used with Node and Express (MEAN & MERN stacks' ME stands for Mongo and Express)</li>
    <li>It's easy to get started with (though it can be tricky to truly master)</li>
    <li>It plays particularly well with JavaScript</li>
    <li>Its popularity also means there is a strong community of developers using Mongo</li>
</ul>

<h4>Running Mongo (mongosh)</h4>
<p>To start Mongo, write on Terminal:</p>
<pre><code>
    brew services start mongodb-community@6.0
</code></pre>
<p>Then, write 'mongosh' to start the shell from where you can control it, create databases, etc.</p>
<p>To create a new database: 'use databaseName'</p>
<p>To show existent databases: 'show dbs' or 'show databases'</p>

<h4>JSON & BSON</h4>
<p>JSON and BSON are close cousins, as their nearly identical names imply, but you wouldn’t know it by looking at them
    side-by-side. JSON, or JavaScript Object Notation, is the wildly popular standard for data interchange on the web,
    on which BSON (Binary JSON) is based. </p>
<p>BSON, or Binary JSON, is the data format that MongoDB uses to organize and store data. This data format includes all
    JSON data structure types and adds support for types including dates, different size integers, ObjectIds, and binary
    data.</p>
<p>MongoDB allows developers to query and manipulate objects by specific keys inside the JSON/BSON document, even in
    nested documents many layers deep into a record, and create high performance indexes on those same keys and values.
    When using a MongoDB driver in your language of choice, it’s still important to know that you’re accessing BSON data
    through the abstractions available in that language.</p>

<h3>Mongo syntax</h3>
<p>A collection is a grouping of MongoDB documents. Documents within a collection can have different fields. A
    collection is the equivalent of a table in a relational database system. Documents are individual records in a
    MongoDB collection and are the basic unit of data in MongoDB.</p>

<h4>Inserting</h4>
<p>The method insert() stands for the C in CRUD.</p>
<p>Adding a new collection in the animalShelter database:</p>
<pre><code>
    db.dogs.insertOne({name: "Charlie", age: 3, breed: "corgi", carFriendly: true})
    <span class="red">pass a normal JS object inside the insertOne() method.</span>

    show collections
    //dogs

    <span class="red">to see what's inside the dogs collection:</span>
    db.dogs.find()
//[
  {
    _id: ObjectId("630a8a06977e8686019719df"),
    name: 'Charlie',
    age: 3,
    breed: 'corgi',
    carFriendly: true
  }
]
</code></pre>
<p>Mongo sets an unique _id for each document (item) included inside a collection.</p>
<p>db.collectionName.insertOne() inserts one document at a time.</p>
<p>db.collectionName.insertMany() inserts several documents at a time (an array of objects).</p>
<p>db.collectionName.insert() does both things.</p>
<p>Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.</p>
<pre><code>
    db.dogs.insert([{name: "Wyatt", breed: "Golden", age: 14, catFriendly: false}, {name: "Tonya", breed: "Chihuahua", age: 17, catFriendly: true}])

    db.dogs.find()
    //[
    {
      _id: ObjectId("630a8a06977e8686019719df"),
      name: 'Charlie',
      age: 3,
      breed: 'corgi',
      carFriendly: true
    },
    {
      _id: ObjectId("630a8e0f977e8686019719e0"),
      name: 'Wyatt',
      breed: 'Golden',
      age: 14,
      catFriendly: false
    },
    {
      _id: ObjectId("630a8e0f977e8686019719e1"),
      name: 'Tonya',
      breed: 'Chihuahua',
      age: 17,
      catFriendly: true
    }
  ]  

    db.cats.insert({name: "Blue Steele", age: 6, dogFriendly: false, breed: "Scottish Fold"})
</code></pre>

<h4>Finding</h4>
<p>The method find() stands for the R in CRUD.</p>
<p>db.collectionName.find() gives all the documents in that collection.</p>
<p>db.collectionName.find({breed: "Corgi"}) will return all documents with that query (case sensitive).</p>
<p><b>db.collectionName.findOne({catFriendly: true})</b> will find one result for that query.</p>

<h4>Updating</h4>
<pre><code>
    db.dogs.updateOne({name: 'Charlie'}, {$set: {age: 4, color: 'chocolate'}})
    <span class="red">sets the age to 4 and creates color key with value 'chocolate'</span>

    db.dogs.updateMany({catFriendly: true}, {$set: {isAvailable: false}})
    <span class="red">in all documents with catFriendly set to true, it sets isAvailable property to false.</span>

    db.cats.updateOne({age: 6}, {$set: {age: 7}, $currentDate: {lastChanged: true}})
    db.cats.find()
    //{ "_id" : ObjectId("5f3c98f5feaedbe6667d5df8"), "name": "Blue Steele", "age": 7, "dogFriendly": false, "breed": "Scottish fold", "lastChanged": ISODate("2022-08-26T05:51:18.584Z") }
    <span class="red">$currentDate is another operator that sets the value of the mentioned property as today's current date.</span>

    db.cats.replaceOne({etcetc: etcetc}, {etcetc:etcetc, etcetc:etcetc})
    <span class="red">replaces an entire document with new data, maintaining the _id</span>
</code></pre>

<h4>Deleting</h4>
<pre><code>
    db.cats.deleteOne({name: "Blue Steele"})

    db.dogs.deleteMany({catFriendly: false})

    db.dogs.deleteMany({})
    <span class="red">deletes all documents in the dogs collection</span>
</code></pre>

<h4>Aditional Mongo operators</h4>
<pre><code>
    db.dogs.find({'personality.childFriendly': true})
    <span class="red">selects the childFriendly property that is nested inside the personality property</span>

    db.dogs.find({age {$gt: 8}})
    <span class="red">finds dogs with an age greater than 8</span>

    db.dogs.find({age {$gte: 8}})
    <span class="red">finds dogs with an age greater or equal to 8</span>

    db.dogs.find({age {$lt: 8}})
    <span class="red">finds dogs with an age lesser than 8</span>

    db.dogs.find({age {$lte: 8}})
    <span class="red">finds dogs with an age lesser or equal to 8</span>

    db.dogs.find({breed: {$in: ['Mutt', 'Corgi']}})
    <span class="red">finds dogs with breed set to Mutt OR Corgi</span>

    db.dogs.find({breed: {$ne: 'Corgi'}})
    <span class="red">finds dogs with breeds not equal to Corgi</span>

    db.dogs.find({breed: {$nin: ['Mutt', 'Chihuahua']}})
    <span class="red">finds dogs that have breed set to neither Mutt or Chihuahua</span>

    db.dogs.find({$or: [{'personality.catFriendly: true'}, {age: {$lte: 2}}]})
    <span class="red">finds dogs that are either cat friendly or with an age less or equal to 2</span>
</code></pre>

<h3>Mongoose</h3>
<p>Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It manages relationships between data,
    provides schema validation, and is used to translate between objects in code and the representation of those objects
    in MongoDB.</p>
<p>ODMs like Mongoose map documents coming from a database into usable JavaScript objects. Mongoose provides ways for us
    to model out our application data and define a schema. It offers easy ways to validate data and build complex
    queries from the comfort of JS.</p>

<h4>Setting up Mongoose</h4>
<pre><code>
    <span class="red">on Terminal</span>
    npm init 
    <span class="red">initiate npm</span>

    npm i mongoose
    <span class="red">install Mongoose</span>

    <span class="red">on index.js</span>
    const mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost:27017/movieApp');
    <span class="red">27017 is the default Mongo port; movieApp is the name of our database</span>

    <span class="red">on Terminal</span>
    node index.js
    <span class="red">this will try to connect with the selected port via mongoose</span>
</code></pre>
<p>Catching connection errors:</p>
<pre><code>
    <span class="red">mongoose.connect() returns a promise, so we can handle errors using then/catch:</span>
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/movieApp')
    .then(() => {
        console.log('CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO ERROR!!!!');
        console.log(err)
    })
</code></pre>

<h4>Mongoose Models</h4>
<p>For each collection, we have to define a Model. A Model in Mongoose is a sort of JavaScript Class.</p>
<p>To define a Model, first we have to set its Schema. A Schema is a map for keys in Mongo for different types in JS.
</p>
<pre><code>
    <span class="red">on index.js</span>
    const movieSchema = new mongoose.Schema({
        title: String,
        year: Number,
        score: Number,
        rating: String
    })
</code></pre>
<p>Then, create a model from that schema using mongoose.model. The first argument in mongoose.model is the model's name
    (always capitalized), the second argument is the schema's name. Mongoose will automatically create a collection
    using the model's name, in lowercase and plural (Movie -> movies).</p>
<pre><code>
    <span class="red">on index.js</span>
    const Movie = mongoose.model('Movie', movieSchema);
</code></pre>
<p>Creating a new Movie instance:</p>
<pre><code>
    <span class="red">on index.js</span>
    const amadeus = new Movie({title: 'Amadeus', year: 1986, score: 9.2, rating: 'R'});
</code></pre>
<p>This creates an object that is an instance of the Movie class on the JS file. It also creates an '_id' property with
    an unique id for that item. To save it to the collection movies on
    the database movieApp, we have to use .save()</p>
<pre><code>
    <span class="red">on index.js</span>
    amadeus.save();
</code></pre>

<h4>insertMany in Mongoose</h4>
<p>insertMany accepts an array of objects and creates several documents at the same time. Documents are automatically
    saved in the database (no need to call .save()).</p>
<pre><code>
    <span class="red">on index.js</span>
    Movie.insertMany([
    { title: 'Amelie', year: 2001, score: 8.3, rating: 'R' },
    { title: 'Alien', year: 1979, score: 8.1, rating: 'R' },
    { title: 'The Iron Giant', year: 1999, score: 7.5, rating: 'PG' },
    { title: 'Stand By Me', year: 1986, score: 8.6, rating: 'R' },
    { title: 'Moonrise Kingdom', year: 2012, score: 7.3, rating: 'PG-13' }
])
</code></pre>

<h4>Finding in Mongoose</h4>
<p>The .find() method in Mongoose returns a thenable query. It is not exactly a promise, but can be handled with
    .then().</p>
<pre><code>
    Movie.find({rating: 'PG-13'}).then(data => console.log(data))
</code></pre>
<p>By using .exec(), we get a real promise, that can be handled with async/await.</p>
<p>.findById('idNumber') is also a very commonly used method.</p>
<pre><code>
    Movie.findById('630bdc37e79dab934485e0b9').then(m => console.log(m));
    // {
        _id: ObjectId("630bdc37e79dab934485e0b9"),
        title: 'Alien',
        year: 1979,
        score: 8.1,
        rating: 'R',
        __v: 0
      }
</code></pre>

<h4>Updating in Mongoose</h4>
<p>The syntax is similar to Mongo's, but without $set.</p>
<pre><code>
    Movie.updateOne({title: 'Amadeus'}, {year: 1984}).then(res => console.log(res));
    <span class="red">will update the year in the document with title 'Amadeus' to 1984</span>
</code></pre>
<p>Updating more than one document:</p>
<pre><code>
    Movie.updateMany({title: {$in: ['Amadeus', 'Stand By Me']}}, {score: 10}).then(res => console.log(res))
    <span class="red">updates the documents with title Amadeus or Stand By Me to have score equal to 10</span>
</code></pre>
<p>By using .findOneAndUpdate with the option 'new' set to true, the thenable query will return the new updated
    document.</p>
<pre><code>
    Movie.findOneAndUpdate({title: 'The Iron Giant'}, {score: 7.8}, {new: true}).then(m => console.log(m))
</code></pre>

<h4>Deleting with Mongoose</h4>
<pre><code>
    Movie.deleteOne({year: {$gte: 1999}}).then(msg => console.log(msg))
    <span class="red">deletes the first occurance</span>

    Movie.deleteMany({year: {$gte: 1999}}).then(msg => console.log(msg))
    <span class="red">delete all</span>

    Movie.findOneAndDelete({title: 'Alien'}).then(m => console.log(m))
    <span class="red">delete one and returns the deleted item</span>
</code></pre>

<h4>Mongoose Schema validations</h4>
<p>In Mongoose, it is possible to set a property to required. If the property is not in the new instance of the model
    created within this Schema, the insertion of that instance-document will not be validated.</p>
<p>Likewise, if the value of any property doesn't match with the type defined on Schema, it also won't be validated -
    unless, for example, it is a string like '522' in a type-Number property, in this case it will be converted to a
    number.</p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
        },
    })
    
    const Product = mongoose.model('Product', productSchema);
    
    const bike = new Product({ name: 'Mountain Bike', price: 599 })
    bike.save()
        .then(data => {
            console.log('IT WORKED!')
            console.log(data)
        })
        .catch(err => {
            console.log('OH NO ERROR!!!!')
            console.log(err)
        })
</code></pre>

<h4>Additional Schema Constraints</h4>
<p>We can define default values for properties on Schemas, as well nest properties. More constraints can be found at
    https://mongoosejs.com/docs/guide.html#definition </p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: 0
            <span class="red">minimum price will be 0</span>
        },
        onSale: {
            type: Boolean,
            default: false
            <span class="red">default value is false</span>
        },
        categories: {
            type: [String],
            <span class="red">it must be an array, only consisting of strings</span>
            default: ['Cycling']
        },
        qty: {
            online: {
                type: Number,
                default: 0
            },
            inStore: {
                type: Number,
                default: 0
            }
        },
        size: {
            type: String,
            enum: ['S', 'M', 'L']
            <span class="red">enum: value must be one of the items of this array</span>
        }
    })
    
    const Product = mongoose.model('Product', productSchema);
    
    const bike = new Product({ name: 'Bike Helmet', price: 599, categories: ['Cycling', 'Safety'], qty: { online: 12, inStore: 2} })
    bike.save()
        .then(data => {
            console.log('IT WORKED!')
            console.log(data)
        })
        .catch(err => {
            console.log('OH NO ERROR!!!!')
            console.log(err)
        })
</code></pre>

<h4>Validating Mongoose Updates</h4>
<p>Whenever we want to update a document in using Mongoose, we have to set the option <b>runValidators</b> to true, in
    order to Mongoose refer again to the Schema validators, and evaluate the inserted properties according to them.</p>
<pre><code>
    Product.findOneAndUpdate({ name: 'Tire Pump' }, {price: 29.99}, {new: true, runValidators: true})
        .then(data => {
            console.log('IT WORKED')
            console.log(data)
        })
        .catch(err => {
            console.log('ERROR!')
            console.log(err)
        })
</code></pre>

<h4>Mongoose Validation Errors</h4>
<p>We can pass error messages to each of the constraints on a Schema.</p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: [0, 'Price must be positive ya dodo!']
            <span class="red">custom error has been set up</span>
        },
        onSale: {
            type: Boolean,
            default: false
        },
        categories: {
            type: [String],
            default: ['Cycling']
        },
        qty: {
            online: {
                type: Number,
                default: 0
            },
            inStore: {
                type: Number,
                default: 0
            }
        }
    })
</code></pre>

<h4>Model Instance Methods</h4>
<p>As in JS Classes, we can create methods inside a Mongoose Schema. These methods will be available in every instance
    of that Schema.</p>
<p>Ex.: creating a method to toggle 'onSale' value from true to false and vice versa:</p>
<pre><code>
    productsSchema.methods.toggleOnSale = function(){
        this.onSale = !this.onSale;
        return this.save();
        <span class="red">'this' will refer to the particular instance where the method was called. Remember that 'this.save()' will return a promise.
        </span>
    }

    const findAndtoggleOnSale = async () => {
        const foundProduct = await Product.findOne({name: 'Mountain Bike'});
        await foundProduct.toggleOnSale();
        console.log(foundProduct);
    }
</code></pre>

<h4>Adding Model Static Methods</h4>
<p>In static methods, the keyword 'this' refer to the Model itself, not to a specific instance.</p>
<p>Ex.: creating a fireSale method, which sets all prices to 0 and puts every instance on sale.</p>
<pre><code>
    productSchema.statics.fireSale = function(){
        return this.updateMany({}, {onSale: true, price: 0})
    }

    Product.fireSale().then(res => console.log(res));

</code></pre>

<h4>Mongoose Virtuals</h4>
<p>Virtuals are "methods" that simulate properties that actually won't be saved in the database, but can retrieved in an
    easy manner.</p>
<pre><code>
    <span class="red">on person.js</span>
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/shopApp')
    .then(() => {
        console.log('CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO ERROR!!!!');
        console.log(err)
    })

    <span class="red">defining a Schema</span>
    const personSchema = new mongoose.Schema({
        first: String,
        last: String
    })

    <span class="red">defining a virtual fullName</span>
    personSchema.virtual('fullName').get(function(){
        return `${this.first} ${this.last}`
    })

    <span class="red">defining a Model</span>
    const Person = mongoose.model('Person', personSchema);

    <span class="red">creating a document (instance)</span>
    const tammy = new Person({first: 'Tammy', last: 'Chow'})
    tammy.save();
    <span class="red">the collection will be called 'people' because Mongo automatically pluralize model's name</span>

    console.log(tammy.fullName);
    //'Tammy Chow'    
</code></pre>
<p>There are also virtual setters (just put .set() after get() and pass in a function), which will actually update the
    values of the properties in the document.</p>

<h4>Mongoose Middlewares</h4>
<p>The Mongoose Middleware are pieces of code that can be executed 'before' or 'after' a method is executed. For
    example, if we remove a user from the database, we will also want to remove all of his comments, posts, etc on the
    database.</p>
<p>Middleware are always executed inside of asynchronous functions.</p>
<pre><code>
    personSchema.pre('save', async function(){
        console.log('ABOUT TO SAVE!');
    });
    <span class="red">this function will run before every save()</span>

    personSchema.post('save', async function(){
        console.log('JUST SAVED!');
    })
    <span class="red">this function will run after every save()</span>

</code></pre>

<h2>Mongoose with Express</h2>
<p>In this section, we learn how to create a simple app, connecting UI to CRUDs via Express, and connecting Express to
    Mongo Server via Mongoose.</p>
<p>UI ---CRUD---> Express ---> Mongoose ---> MongoDB</p>
<h4>Express + Mongoose basic setup</h4>
<pre><code>
    <span class="red">on terminal</span>
    npm init -y 
    npm i express ejs mongoose

    <span class="red">on index.js</span>
    const express = require('express');
    const app = express();
    const path = require('path');
    const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/farmStand')
    .then(() => {
        console.log('MONGO CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO Mongo connection ERROR!!!!');
        console.log(err)
    })

    app.set('views', path.join(__dirname, 'views'));
    app.set('view engine', 'ejs');

    app.get('/dog', (req, res) => {
        res.send('WOOF!');
    })

    app.listen(3000, () => {
        console.log('APP IS LISTENING ON PORT 3000!')
    })
</code></pre>

<h4>Creating our Model (E+M)</h4>
<p>We'll start by creating a 'models' folder; each model will be kept in a single .js file. On each model file, we have
    only to require 'mongoose'; we are not connecting to the database from this files; instead, we are requiring this
    model files into index.js, which will connect them and feed the database.</p>
<pre><code>
    <span class="red">on models/products.js</span>
    const mongoose = require('mongoose');

    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: 0
        },
        category: {
            type: String,
            enum: ['fruit', 'vegetable', 'dairy']
        }
    })

    const Product = mongoose.model('Product', productSchema);

    module.exports = Product;

    <span class="red">on index.js</span>
    const Product = require('./models/product')
</code></pre>
<p>In order to feed the database with new data whenever needed, we'll create a 'seeds.js' file; this file is created
    only for development purposes. This file will require the models and also connect to Mongoose.</p>
<pre><code>
    <span class="red">on seeds.js</span>
    <span class="red">requiring Product and mongoose, connecting to mongodb via mongoose</span>
    const mongoose = require('mongoose');

    const Product = require('./models/product')

    mongoose.connect('mongodb://localhost:27017/shopApp')
    .then(() => {
        console.log('MONGO CONNECTION OPEN!!!')
    })
    .catch(err => {
        console.log('OH NO Mongo connection ERROR!!!!');
        console.log(err)
    })

    <span class="red">creating a new product document</span>
    const p = new Product({
        name: 'Ruby Grapefruit',
        price: 1.99,
        category: 'fruit'
    });
    p.save().then(p => {
        console.log(p);
    })
    .catch(e => {
        console.log(e)
    })

    <span class="red">on node shell on terminal:</span>
        node seeds.js

    <span class="red">on mongoose shell on terminal</span>
        show dbs 
        use farmStand 
        show collections
        db.products.find()
        <span class="red">//the document for 'Ruby Grapefruit' will appear here</span>
</code></pre>
<p>Seeding the database with more products:</p>
<pre><code>
    const seedProducts = [
    {
        name: 'Fairy Eggplant',
        price: 1.00,
        category: 'vegetable'
    },
    {
        name: 'Organic Goddess Melon',
        price: 4.99,
        category: 'fruit'
    },
    {
        name: 'Organic Mini Seedless Watermelon',
        price: 3.99,
        category: 'fruit'
    },
    {
        name: 'Organic Celery',
        price: 1.50,
        category: 'vegetable'
    },
    {
        name: 'Chocolate Whole Milk',
        price: 2.69,
        category: 'diary'
    },
]

Product.insertMany(seedProducts)
    .then(res => {
        console.log(res)
    })
    .catch(e => {
        console.log(e)
    })
</code></pre>

<h4>Generating products index page</h4>
<p>Now we go back to index.js and request the products documents from the database:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const products = await Product.find({});
        console.log(products);
        res.send('ALL PRODUCTS WILL BE HERE!');
    })
</code></pre>
<p>We will create a folder called 'views', inside of it create a folder called 'products'. Inside the 'products' folder,
    create a file called 'index.ejs'. Now we can render './views/products/index.ejs' as our get response:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const products = await Product.find({});
        console.log(products);
        res.render('products/index', { products });
        <span class="red">don't forget to pass { products } through the render to get access to them on 'index.ejs'.</span>
    })
</code></pre>

<h4>Products details page</h4>
<p>Creating a default details page for the products:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/:id', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findById(id);
        res.render('products/show', { product });
    })

    <span class="red">on views/products/show.ejs</span>
    < h1>
        <%= product.name %>
    < /h1>
    < ul>
        < li>Price: $<%= product.price %>
        < /li>
        < li>Category: <%= product.category %>
        < /li>
    < /ul>
</code></pre>
<p>Now on the 'all products' page (views/products/index.ejs) we can transform each product's name into a link to its
    details page:</p>
<pre><code>
    < h1>All Products</h1>
    < ul>
        <% for(let product of products) { %>
            < li>
                < a href="/products/<%=product._id%>">
                    <%= product.name %>
                < /a>
            < /li>
            <% } %>
    < /ul>
</code></pre>

<h4>Creating new products</h4>
<p>In order to create new products, we first have to define a GET route to a form, where the user will provide the new
    product data. Then we have to create a POST route to actually insert the new product's data into the database.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/new', (req, res) => {
        res.render('products/new');
    })

    <span class="red">on views/products/new.ejs</span>
    <h1>Add a Product</h1>
    <form action="/products" method="POST">
        < label for="name">Product name: </ label>
        < input type="text" name="name" id="name" placeholder="product name">
        < label for="price">Price (unit): < /label>
        < input type="number" id="price" name="price" placeholder="price">
        < label for="category">Select category: < /label>
        < select name="category" id="category">
            < option value="fruit">fruit< /option>
            < option value="vegetable">vegetable</ option>
            < option value="diary">diary< /option>
        < /select>
        < button>Add product< /button>
    < /form>
</code></pre>
<p>Defining POST route:</p>
<pre><code>
    <span class="red">on index.js</span>
    app.use(express.urlencoded({extended: true}));
    <span class="red">remember, this is necessary to get access to the submitted form queries/values</span>

    <span class="red">still on index.js</span>
    app.post('/products', async (req, res) => {
        const newProduct = new Product(req.body);
        await newProduct.save();
        res.redirect(`/products/${newProduct._id}`);
    })
</code></pre>
<p>Now put a link to the form on the product's index page:</p>
<pre><code>
    <span class="red">on index.ejs</span>
    < a href="/products/new">Add new product< /a>
</code></pre>

<h4>Updating products (E+M)</h4>
<p>As with creating new products, first we have to define a GET route to a form page, then create an 'edit.ejs' page,
    then define a POST route to
    update the database.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/products/:id/edit', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findById(id)
        res.render('products/edit', { product });
    })

    <span class="red">on views/products/edit.ejs</span>
    < h1>Edit Product</h1>
    < form action="/products/<%=product._id%>" method="POST">
        < label for="name">Product name: < /label>
        < input type="text" name="name" id="name" placeholder="product name" value="<%=product.name%>">
        < label for="price">Price (unit): < /label>
        < input type="number" id="price" name="price" placeholder="price" value="<%=product.price%>">
        < label for="category">Select category: < /label>
        < select name="category" id="category">
            < option value="fruit">fruit< /option>
            < option value="vegetable">vegetable< /option>
            < option value="diary">diary< /option>
        < /select>
        < button>Submit< /button>
    < /form>
</code></pre>
<p>To define an update route, we must use PUT or PATCH verbs. But, remember, HTML forms don't accept these verbs, only
    accept POST or GET, so we have to install, require and use the 'method-override' package.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i method-override

    <span class="red">on index.js</span>
    const methodOverride = require('method-override');
    app.use(methodOverride('_method'));

    <span class="red">on edit.ejs</span>
    < form action="/products/<%=product._id%>?_method=PUT" method="POST">< /form>

    <span class="red">on index.js</span>
    app.put('/products/:id', async (req, res) => {
        const { id } = req.params;
        const product = await Product.findByIdAndUpdate(id, req.body, { runValidators: true, new: true });
        res.redirect(`/products/${product._id}`);
    })
</code></pre>
<p>Now we have to put a link in each product details page.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    < a href="/products/<%=product._id%>/edit">Edit Product</a>
</code></pre>
<p>And put a link on edit page to cancel edit:</p>
<pre><code>
    < a href="/products/<%=product._id%>">Cancel</a>
</code></pre>
<p>This part is just a small detail. On the edit page, the actual category of the product will not be presented, unless
    we add some logic there. There is an HTML attribute called selected, which accepts a boolean as its value. If it is
    true, then the option will be set to selected as default.</p>
<pre><code>
    <span class="red">on edit.ejs</span>
    < select name="category" id="category">
        < option value="fruit" <%=product.category==='fruit' ? 'selected' : '' %>>fruit< /option>
        < option value="vegetable" <%=product.category==='vegetable' ? 'selected' : '' %>>vegetable< /option>
        < option value="diary" <%=product.category==='diary' ? 'selected' : '' %>>diary< /option>
    < /select>
</code></pre>

<h4>Deleting products (E+M)</h4>
<p>As with updating, in order to make a DELETE request using a HTML form, we have to make use of 'method-override'.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    < form action="/products/<%=product._id%>?_method=DELETE" method="POST">
        < button>Delete</ button>
    < /form>
</code></pre>

<h4>Bonus: Filtering by Category</h4>
<p>To show a page with all vegetables, all fruits or all dairies, we will add query strings to the request when clicking
    a category name.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    <ul>
        <li>Price: $<%= product.price %>
        </li>
        <li>Category: <a href="/products?category=<%= product.category %>">
                <%= product.category %>
            </a>
        </li>
    </ul>

    <span class="red">on index.js</span>
    app.get('/products', async (req, res) => {
        const { category } = req.query;
        if (category) {
            const products = await Product.find({ category: category });
            res.render('products/index', { products, category });
        } else {
            const products = await Product.find({}); res.render('products/index', { products, category: 'All' });
        }
    })

    <span class="red">on index.ejs</span>
    <h1>
        <%= category %> Products
    </h1>
</code></pre>

<h3>Middlewares in Express</h3>
<p>Here begins Colt's section 40.</p>
<p>Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.</p>
<p>Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.</p>
<p>Middlewares can end the HTTP request by sending back a response with methods like <b>res.send()</b>. Or middlewares can be chained together, one after another by calling <b>next()</b>.</p>

<h4>next()</h4>
<p>As we talked earlier, <b>app.use(< somemiddleware>)</b> will be executed in every single request that is made. The function <b>nest()</b> can be called in order to keep executing the next middlewares inside of other routes that match the requested path.</p>
<pre><code>
    app.use((req, res, next) => {
        console.log('THIS IS MY FIRST MIDDLEWARE!');
        return next();
    })
    app.use((req, res, next) => {
        console.log('THIS IS MY SECOND MIDDLEWARE!');
        return next();
    })
    <span class="red">for every HTTP request, will log:
        //THIS IS MY FIRST MIDDLEWARE!
        //THIS IS MY SECOND MIDDLEWARE!
        and then search for any matching route
    </span>
</code></pre>
<pre><code>
    app.use((req, res, next)=> {
        console.log(req.path, req.method.toUpperCase());
        next();
    })
    <span class="red">will console.log the path and the method of every request</span>
</code></pre>

<h4>Setting up a 404 route</h4>
<p>As the last route on our file, just before app.listen, we can write an app.use to catch all the NOT FOUND requests:</p>
<pre><code>
    app.use((req, res) =>{
        res.status(404).send('NOT FOUND!');
        <span class="red">status(404) will set the status of the response to 404</span>
    })
</code></pre>

<h4>Using callbacks to call middlewares</h4>
<p>app.method (app.get, app.post etc) routes accept callback functions that will trigger once that route is requested. These callback functions must contain the next() method as its last line, otherwise the route will stop executing there.</p>
<pre><code>
    const verifyPassword = (req, res, next) => {
        const { password } = req.query;
        if (password === 'chickennugget') {
            next();
        } else {
            res.send('SORRY YOU NEED A PASSWORD');
        }
    }

    app.get('/secret', <b>verifyPassword</b>, (req, res) => {
        res.send('MY SECRET IS: Sometimes I wear I wear headphones in public so I dont have to talk to anyone');
    })    
</code></pre>

<h4>ejs-mate package</h4>
<p><b>ejs-mate</b> is a package that makes creating templates even more easy.</p>
<pre><code>
    <span class="red">on terminal</span>
    npm i ejs-mate

    <span class="red">on app.js</span>
    const ejsMate = require('ejs-mate');

    app.engine('ejs', ejsMate);

    <span class="red">then inside of /views create a layouts folder, and a file boilerplate.ejs inside of it</span>

    <span class="red">on boilerplate.ejs</span>
    <body>
        <h1>BEFORE</h1>
        <%- body %>
        <h1>AFTER</h1>
    </body>

    <span class="red">on every page we want to apply the template (remove head if it is in that boilerplate;)</span>
    <% layout('layouts/boilerplates') %>

</code></pre>

<h3>Handling errors in Express</h3>
<p>Colt Steele section 42.</p>
<p>Express comes with a built-in error handler that takes care of any errors that might be encountered in the app. We also can customize the error messages, throwing errors:</p>
<pre><code>
    const verifyPassword = (req, res, next) => {
        const { password } = req.query;
        if (password === 'chickennugget') {
            next();
        } else {
            throw new Error('Password required!');
        }
    }
    <span class="red">the error message will be shown as the first line of the built-in error</span>
</code></pre>
<p>Define error-handling middleware functions in the same way as other middleware functions, except error-handling functions have four arguments instead of three: <b>(err, req, res, next)</b>. For example:</p>
<pre><code>
    app.use((err, req, res, next) => {
        console.log('***********************');
        console.log('*********ERROR**********');
        console.log('***********************');
        next(err);
    })
    <span class="red">if you pass err to next(), Express will handle the error with its built-in error handler.</span>
</code></pre>
<p>You define error-handling middleware last, after other app.use() and routes calls.</p>

<h4>Defining a Error Class</h4>
<p></p>
<pre><code>
    <span class="red">on AppError.js</span>
    class AppError extends Error {
        constructor(message, status){
            super();
            this.message = message;
            this.status = status;
        }
    }
    module.exports = AppError;

    <span class="red">on index.js</span>
    const AppError = require('./AppError');

    const verifyPassword = (req, res, next) => {
        const { password } = req.query;
        if (password === 'chickennugget') {
            next();
        } else {
            throw new AppError('Password required!', 401);
        }
    }

    app.use((err, req, res, next) => {
        const { status = 500, message = 'Something Went Wrong' } = err;
        res.status(status).send(message);
    })
</code></pre>

<h4>Handling async errors</h4>
<p>It is good practice to always wrap our code inside try/catch inside of async routes.</p>
<pre><code>
    app.get('/products/:id', async (req, res, next) => {
        try {
            const { id } = req.params;
            const product = await Product.findById(id);
            if (!product) {
                throw new AppError('Product Not Found', 404);
            }
            res.render('products/show', { product });
        } catch(e) {
            next(e);
        }
    })
</code></pre>
<p>In this case, we are handling the product id error with a custom message. If such an error ocurrs, it will be thrown and catched by next(e). If any other error occurs, it will also be catched. The next(e) will send this error directly to the app.use(err, req, res, next) route.</p>

<h4>Defining a wrapAsync() catch utility</h4>
<p>Instead of wrapping every single async function in our Express routes in try/catch, we can refactor the error handling of async functions in Express apps by creating a catch utility:</p>
<pre><code>
    <span class="red">defining wrapAsync function:</span>
    function wrapAsync(fn) {
        return function(req, res, next) {
            fn(req, res, next).catch(e => next(e));
        }
    }

    <span class="red">wraping every async route inside of it:</span>
    app.get('/products/:id', wrapAsync(async (req, res, next) => {
        const { id } = req.params;
        const product = await Product.findById(id);
        if (!product) {
            throw new AppError('Product Not Found', 404);
        }
        res.render('products/show', { product });
    }))
</code></pre>
<p>All of this is valid only if we are using Express v4. In Express v5 all of this is not necessary anymore.</p>

<h4>Differentiating Mongoose errors</h4>
<p>We can differentiate the way we handle different errors that came from Mongoose (eg, invalid ids, validation errors - user not provides a value for a required field on a form) by getting the err properties, like <b>err.name</b> or <b>err.message</b>. Express errors don't have a name property, but Mongoose errors do have, so we can differentiate how we handle each one.</p>
<pre><code>
    const handleValidationError = err => {
        console.log(err.name)
        <span class="red">or we can open a custom page that explains to the user what is missing</span>
    }

    app.use((err, req, res, next) => {
        console.log(err.name);
        if (err.name === 'ValidationError') err =   handleValidationError(err);
        next(err);
    })
</code></pre>

<h4>Client-side Form Validations</h4>
<p>First of all, we can count on the browser html form validation, by adding the <b>required</b> attribute in the input element in HTML. It works well, but we can use Bootstrap to make it more user-friendly.</p>
<p>CSS Framework Bootstrap has a client-side form validation. Docs: https://getbootstrap.com/docs/5.2/forms/validation/  </p>
<p>1. Add <b>required</b> attribute to all input elements you want to require.</p>
<p>2. Add <b>novalidate</b> attribute to the form element. This will prevent the browser to run the default html validation.</p>
<pre><code>
    <span class="red">on new.ejs</span>
    < form action="/campgrounds" method="POST" <b>novalidate class="validated-form"</b>>
        < div class="mb-3">
            < label class="form-lable" for="title">Title: </>
            < input class="form-control" type="text" name="campground[title]" id="title" <b>required</b>>
        < /div>
</code></pre>
<p>3. Copy/paste the JS code to prevent the form from being submitted if the required fields are empty: https://getbootstrap.com/docs/5.2/forms/validation/</p>
<pre><code>
    <span class="red">on new.ejs</span>
    <script>
    // Example starter JavaScript for disabling form submissions if there are invalid fields
(() => {
  'use strict'

  // Fetch all the forms we want to apply custom Bootstrap validation styles to
  const forms = document.querySelectorAll('.validated-form')

  // Loop over them and prevent submission
  Array.from(forms).forEach(form => {
    form.addEventListener('submit', event => {
      if (!form.checkValidity()) {
        event.preventDefault()
        event.stopPropagation()
      }

      form.classList.add('was-validated')
    }, false)
  })
})()
</script>
</code></pre>
<p>4. If we want, we can add a div.valid-feedback under each input and add a message like 'Looks good!' inside of this div.</p>
<pre><code>
    <span class="red">on new.ejs</span>
    < form action="/campgrounds" method="POST" <b>novalidate class="validated-form"</b>>
        < div class="mb-3">
            < label class="form-lable" for="title">Title: </>
            < input class="form-control" type="text" name="campground[title]" id="title" <b>required</b>>
            < div class="valid-feedback">Looks good!</>
        < /div>
</code></pre>

<h4>Server-side validation: JOI</h4>
<p>Up to now, client-side validation is ready, so the user won't be able, for example, to add a new Campground with no title. But the user could still use some out-browser tool to post a request, like Postman. So we have also to guarantee validation of forms on the server-side.</p>
<p>We can easily do that using JOI. JOI is a JS tool, not-Express-specific, to validate Schemas in a database model.</p>
<pre><code>
    <span class="red">on terminal</span>
    npm i joi

    <span class="red">on app.js</span>
    const Joi = require('joi');

    app.post('/campgrounds', catchAsync(async (req, res, next) => {
        <b>const campgroundSchema = Joi.object({
            campground: Joi.object({
                title: Joi.string().required(),
                price: Joi.number().required().min(0),
                image: Joi.string().required(),
                location: Joi.string().required(),
                description: Joi.string().required()
            }).required()
        })
        const { error } = campgroundSchema.validate(req.body);
        if (error) {
            const msg = error.details.map(el => el.message).join(',');
            throw new ExpressError(msg, 400);
        }</b>
        
        const campground = new Campground(req.body.campground);
        await campground.save();
        res.redirect(`/campgrounds/${campground._id}`);
    }))
</code></pre>
<p>As we can see above, this campgroundSchema is used by Joi to validate (or not) the provided object (req.body). Joi will compare the properties in req.body with those that are specificated in campgroundSchema; in case of non-validation, Joi will create an error that can be thrown or desconstructed.</p>

<h4>Creating a JOI validation middleware</h4>
<p>In order to refactor this route (and in order to be able to reuse this code on other routes), we will create a validation middleware.</p>
<pre><code>
    <span class="red">on schemas.js</span>
    const Joi = require('joi');

    module.exports.campgroundSchema = Joi.object({
    campground: Joi.object({
        title: Joi.string().required(),
        price: Joi.number().required().min(0),
        image: Joi.string().required(),
        location: Joi.string().required(),
        description: Joi.string().required()
    }).required()
    });
    
    <span class="red">on app.js</span>
    const { validateCampground } = require('./schemas');
    
    const validateCampground = (req, res, next) => {
        const { error } = campgroundSchema.validate(req.body);
        if (error) {
            const msg = error.details.map(el => el.message).join(',');
            throw new ExpressError(msg, 400);
        } else {
            next();
        }
    }

    app.post('/campgrounds', validateCampground, catchAsync(async (req, res, next) => {
        // if(!req.body.campground) throw new ExpressError('Invalid Campground Data', 400);
    
        const campground = new Campground(req.body.campground);
        await campground.save();
        res.redirect(`/campgrounds/${campground._id}`);
    }))

    app.put('/campgrounds/:id', validateCampground, catchAsync(async (req, res) => {
        const { id } = req.params;
        const campground = await Campground.findByIdAndUpdate(id, { ...req.body.campground });
        res.redirect(`/campgrounds/${campground._id}`)
    }))
</code></pre>

<h3>Data Relationships with Mongo</h3>
<p>When a database stores users and also their comments, reviews, posts and likes, we will have to handle data relationships to make, for example, an user's posts related (and "belonging") to this specific user. This user will have some permissions over this post that other users don't, for example, he can delete or edit this post.</p>

<h4>One to Few relationships</h4>
<p>These are relationships where there is just a limited number of items that relate to the one that is being considered. For example, a user who has 2 or 3 addresses.</p>
<pre><code>
    const mongoose = require('mongoose');

    mongoose.connect('mongodb://localhost:27017/relationshipDemo')
        .then(() => {
            console.log('Mongo Connection open!');
        })
        .catch(err => {
            console.log('Mongo Connection error!')
            console.log(err);
        })

    const userSchema = new mongoose.Schema({
        first: String,
        last: String,
        addresses: [
            {
                street: String,
                city: String,
                state: String,
                country: String
            }]
    })

    const User = mongoose.model('User', userSchema);

    const makeUser = async () => {
        const u = new User({
            first: 'Harry',
            last: 'Potter'
        });
        u.addresses.push({
            street: '123 Sesame St.',
            city: 'New York',
            state: 'NY',
            country: 'USA'
        })
        const res = await u.save();
        console.log(res);
    }
    makeUser();
</code></pre>
<p>Mongo will add a new ID to each address. If we don't want that, we can add _id: {id: false} as one of the Schema properties.</p>
<p>Adding another address to the same user:</p>
<pre><code>
    const addAddress = async (id) => {
        const user = await User.findById(id);
        user.addresses.push({
            street: '99 3rd St.',
            city: 'New York',
            state: 'NY',
            country: 'USA'
        })
        const res = await user.save();
        console.log(res);
    }
    addAddress(73u3hhe738289e933eds)
</code></pre>

<h4>One to Many relationships</h4>
<p>When there are a lot of items that relate to a property in one document, we can store the items in a different Schema, different model, and then relate them using their ids.</p>
<pre><code>
    const productSchema = new mongoose.Schema({
        name: String,
        price: Number,
        season: {
            type: String,
            enum: ['Spring', 'Summer', 'Fall', 'Winter']
        }
    });
    
    const Product = mongoose.model('Product', productSchema);

    Product.insertMany([
        { name: 'Goddess Melon', price: 4.99, season: 'Summer' },
        { name: 'Sugar Baby Watermelon', price: 4.99, season: 'Summer' },
        { name: 'Aspargus', price: 3.99, season: 'Spring' }
    ]);

    const farmSchema = new mongoose.Schema({
        name: String,
        city: String,
        products: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Product'}]
        <span class="red">this means this property will accept ObjectID types
        for example: ObjectID('73673hduhueh82')
        The 'ref' property indicates which model to use during population.
        </span>
    })    

    const Farm = mongoose.model('Farm', farmSchema);

    const makeFarm = async () => {
        const farm = new Farm({ name: 'Full Belly Farms', city: 'Guinda, CA', });
        const melon = await Product.findOne({ name: 'Goddess Melon'});
        farm.products.push(melon);
        await farm.save();
        console.log(farm);
    }
    makeFarm();
</code></pre>
<p>As a result of the above script, Mongo will create a document for the farm 'Full Belly Farms' with the 'Goddess Melon' as a product, but the product will only be referenced by its _id, like this: ObjectID('7iuheuh7387h2i2o').</p>
<p>Adding more products to a farm:</p>
<pre><code>
    const addProduct = async () => {
        const farm = await Farm.findOne({ name: 'Full Belly Farms'});
        const watermelon = await Product.findOne({ name: 'Sugar Baby Watermelon' });
        farm.products.push(watermelon);
        await farm.save();
        console.log(farm);
    }
</code></pre>

<h4>Mongoose Populate</h4>
<p>The Mongoose <b>.populate('property')</b> method allows us to populate a document with actual data from the nested documents. It will use as a reference the 'ref' that was provided when defining the parent's Schema.</p>
<pre><code>
    Farm.findOne({ name: 'Full Belly Farms' })
        .then(farm => console.log(farm));
    <span class="red">this will show the farm document but the 'products' property will contain only the ids of the products.</span>

    Farm.findOne({ name: 'Full Belly Farms' })
        .populate('products')
        .then(farm => console.log(farm));
    <span class="red">this will populate the 'products' property will all data, data will be constructed using 'ref' model.</span>
</code></pre>

<p>Note from the future (Colt lecture 525): populating only one field + nested populations (populating one field inside of another field):</p>
<pre><code>
    router.get('/:id', catchAsync(async (req, res) => {
        const campground = await Campground.findById(req.params.id).populate({
            path: 'reviews',
            populate: {
                path: 'author',
                select: 'username'
            } <span class="red">will populate 'reviews' and also every reviews' author; 
            will only populate 'username' field of review's author.</span>
        }).populate('author', 'username');
        <span class="red">will populate only the 'username' field on 'author'. (that's the same as using <b>select</b> in the detailed object version.</span>
        if(!campground){
            req.flash('error', 'Sorry, campground not found');
            return res.redirect('/campgrounds');
        }
        res.render('campgrounds/show', {campground})
    }))
</code></pre>
<p>More info on populate(): https://mongoosejs.com/docs/api.html#query_Query-populate </p>

<h4>One to "bajillions" relationships</h4>
<p>When there are thousands or more children documents, it's more efficient to store a reference to the parent on the child document.</p>
<p>For example, a user is the author of hundreds of tweets:</p>
<pre><code>
    const userSchema = new mongoose.Schema({
        username: String,
        age: Number
    });

    const tweetSchema = new mongoose.Schema({
        text: String,
        likes: Number,
        user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
    });

    const User = mongoose.model('User', userSchema);
    const Tweet = mongoose.model('Tweet', tweetSchema);

    const makeTweets = async () => {
        const user = new User({ username: 'chickenfan99', age: 61 });
        const tweet1 = new Tweet({ text: 'omg I love my chicken family!', likes: 0 });
        tweet1.user = user;
        user.save();
        tweet1.save();
    }
    makeTweets();
</code></pre>
<p>Adding a new tweet:</p>
<pre><code>
    const makeTweets = async () => {
        const user = await User.findOne({ username: 'chickenfan99' });
        const tweet2 = new Tweet({ text: 'bock bock my chicken makes noises', likes: 1239 });
        tweet2.user = user;
        tweet2.save();
    }
    makeTweets();
</code></pre>
<p>Populating a tweet (child) document with its user (parent)'s data:</p>
<pre><code>
    const findTweet = async () => {
        const t = await Tweet.findOne({});
        console.log(t);
    }
    <span class="red">only shows the user's id</span>

    const findTweet = async () => {
        const t = await Tweet.findOne({}).populate('user');
        console.log(t);
    }
    <span class="red">will show user's complete data</span>

    const findTweet = async () => {
        const t = await Tweet.findOne({}).populate('user', 'username');
        console.log(t);
    }
    <span class="red">will only show 'username' property of 'user'</span>
</code></pre>

<h4>Mongo relationships with Express</h4>
<p>Colt Steele's lecture 460.Refering to mongoose-basics demo project.</p>
<p>In this section we are going to add a 'farm' model and associate different farms to different products.</p>
<p>Our relationship strategy will be to mutually associate farms to products (each product will have a farm property) and products to farms (each farm will have a products property).</p>
<pre><code>
    <span class="red">creating farm.js (schema and model for farms)</span>
    const mongoose = require('mongoose');
    const { Schema } = mongoose;

    const farmSchema = new Schema({
        name: {
            type: String,
            required: [true, 'Farm must have a name!']
        },
        city: {
            type: String,
        },
        email: {
            type: String, 
            required: [true, 'Email required']
        },
        products: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Product'
            }]
    })
    const Farm = mongoose.model('Farm', farmSchema);
    module.exports = Farm;

    <span class="red">include a 'farm' property on productSchema:</span>
    const productSchema = new mongoose.Schema({
        name: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true,
            min: 0
        },
        category: {
            type: String,
            lowercase: true,
            enum: ['fruit', 'vegetable', 'diary']
        },
        <b>farm: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Farm'
        }</b>
    })
</code></pre>
    <p>Adding a 'create new farm' route:</p>
    <pre><code>
        <span class="red">on index.js (route to the form)</span>
        app.get('/farms/new', (req, res) => {
            res.render('farms/new');
        })

        <span class="red">on farms/new.ejs</span>
        < h1>Add a Farm</>
    < form action="/farms" method="POST">
        < div>
            < label for="name">Farm name: </>
            < input type="text" name="name" id="name" placeholder="farm name">
        < /div>
        < div>
            < label for="city">City: </>
            < input type="text" name="city" id="city" placeholder="farm city">
        < /div>
        < div>
            < label for="email">E-mail: </>
            < input type="email" name="email" id="email" placeholder="farm email">
        < /div>
        
        < button>Add farm</>
    </ form>

    <span class="red">on index.js (defining a post route)</span>
        const Farm = require('./models/farm');
        app.post('/farms', async (req, res) => {
            const farm = new Farm(req.body);
            await farm.save();
            res.redirect('/farms')
        })

    <span class="red">'show all farms' route, on index.js</span>
    app.get('/farms', async (req, res) => {
        const farms = await Farm.find({});
        res.render('farms/index', { farms });
    })

    <span class="red">on /farms/index.ejs</span>
    < h1>
        All Farms
    </ h1>
    < ul>
        <% for(let farm of farms) { %>
            < li><%= farm.name %></ li>
            <% } %>
    </ ul>
</code></pre>

<p>Creating a 'show' page for each farm:</p>
<pre><code>
    <span class="red">on index.js (this route must come after /farms/new, 
    otherwise the app will read 'new' as an id!</span>
    app.get('/farms/:id', async (req, res) => {
        const farm = await Farm.findById(req.params.id);
        res.render('farms/show', { farm });
    })

    <span class="red">on /farms/index.ejs (adding a link)</span>
    < h1>
        All Farms
    </ h1>
    < ul>
        <% for(let farm of farms) { %>
            < li>< a href="/farms/<%=farm._id%>"><%= farm.name %></></ li>
            <% } %>
    </ ul>

    <span class="red">creating /farms/show.ejs</span>
    < h1>
        <%= farm.name %>
    </ h1>
    < ul>
        < li>City: <%= farm.city %>
        </ li>
        < li>E-mail: <%= farm.email %>
        </ li>
    </ ul>
    < a href="/farms">All Farms</ a>
</code></pre>

<p>Here begins the fresh new part of this section! How to create a new product from inside of a farm's view page, associating this product with that farm?</p>
<p>The pattern we'll going to use is <b>/farms/:farm_id/products/new</b> for creating a new product, and <b>/farm/:farm_id/products/:id</b> to view that product.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/farms/:id/products/new', (req, res) => {
        const { id } = req.params;
        res.render('products/new', { categories, id })
    })

    <span class="red">on products/new.ejs
        (change the path to the form to be submitted)
    </span>
    < form action="/farms/<%=id%>/products" method="POST">< /form>

    <span class="red">on index.js (create post route)</span>
    app.post('/farms/:id/products', async (req, res) => {
        const { id } = req.params; <span class="red">req.params comes from the requested address (/farms/:id/products) </span>
        const farm = await Farm.findById(id);
        const { name, price, category } = req.body; <span class="red">req.body comes from the form that was submitted</span>
        const product = new Product({ name, price, category });
        farm.products.push(product); <span class="red">associates this product with this farm</span>
        product.farm = farm; <span class="red">associates this farm with this product</span>
        await farm.save();
        await product.save();
        res.redirect(`/farms/${id}`);
    })
    <span class="red">on /farms/show.ejs</span>
    < a href="/farms/<%=farm.id%>/products/new">Add Product< /a>

</code></pre>

    <p>Showing products on each farm's show page:</p>
    <pre><code>
        <span class="red">populating product's ids on index.js</span>
        app.get('/farms/:id', async (req, res) => {
            const farm = await (await Farm.findById(req.params.id))<b>.populate('products')</b>;
            res.render('farms/show', { farm });
        })

        <span class="red">on /farms/show.ejs</span>
        < h2>Products:</ h2>
    < ul>
        <% for(let product of farm.products){%>
        < li><%=product.name%>< /li>
        <%}%>
    < /ul>
    </code></pre>

    <p>Adding the farm name to 'new.ejs':</p>
    <pre><code>
        <span class="red">on index.js</span>
        app.get('/farms/:id/products/new', async (req, res) => {
            const { id } = req.params;
            <b>const farm = await Farm.findById(id);</b>
            res.render('products/new', { categories, <b>farm</b> })
        })

        <span class="red">on products/new.ejs</span>
        < h1><b><%=farm.name%></b></ h1>
    < h2>Add a Product</ h2>
    < form action="/farms/<%=<b>farm._id</b>%>/products" method="POST">
    </code></pre>

    <p>Showing the farm name on each product's view:</p>
    <pre><code>
        <span class="red">on index.js</span>
        app.get('/products/:id', async (req, res) => {
            const { id } = req.params;
            const product = await (await Product.findById(id))<b>.populate('farm', 'name')</b>;
            res.render('products/show', { product });
        })
    </code></pre>

    <p>Deleting one item from an array. Colt lecture 473. In order to delete just one item from an array in a property that accepts one array of items, we can use the keyword $pull in Mongo/Mongoose. The $pull operator in MongoDB removes from an existing array all instances of a value or values that match a specified condition:</p>
    <pre><code>
        app.delete('/campgrounds/:id/reviews/:reviewId', catchAsync(async (req, res) => {
            const { id, reviewId } = req.params;
            await Campground.findByIdAndUpdate(id, { $pull: { reviews: reviewId } }); <span class="red">deleting from the campgrounds collection</span>
            await Review.findByIdAndDelete(reviewId); <span class="red">deleting from the reviews collection</span>
            res.redirect(`/campgrounds/${id}`)
        }))
    </code></pre>

    <p>Delete route: Mongoose Middleware. We not only want to delete a farm, we would like to delete also the products associated with that farm. In order to do that, we have to define a Mongoose Middleware (don't confuse with Express Middleware, which are defined on the routes script). Mongoose Middlewares are defined on the models script (see below).</p>
    <pre><code>
        <span class="red">on index.js</span>
        app.delete('/farms/:id', async (req, res) => {
            const farm = await Farm.findByIdAndDelete(req.params.id);
            res.redirect('/farms');
        })

        <span class="red">on farms/show.ejs</span>
        < form action="/farms/<%=farm._id%>?_method=DELETE" method="POST">< button>Delete< /button>< /form>

        <span class="red">on /models/farm.js</span>
        const Product = require('./product');
        farmSchema.post('findOneAndDelete', async function (farm) {
            if(farm.products.length) {
                const res = await Product.deleteMany({_id: {$in: farm.products}});
                console.log(res);
            }
        });
    </code></pre>

<h3>Express Router</h3>
<p>À medida que as rotas de um sistema crescem, é uma boa prática separar essas rotas em arquivos, imagine 100 rotas no mesmo arquivo, dificulta muito a manutenção.</p>
<p>Para fazer isso existe o express.Router, com ele é possível escrever todas as rotas relacionadas em um arquivo e depois exportar elas para que seja usado no arquivo principal, com isso as rotas de um módulo ficam separadas.</p>

<pre><code>
    <span class="red">on /routes/shelters.js</span>
    const express = require('express');
    const router = express.Router();

    router.get('/shelters', (req, res) => {
        res.send('ALL SHELTERS')
    })

    router.post('/shelters', (req, res) => {
        res.send('CREATING A SHELTER')
    })

    router.get('/shelters/:id', (req, res) => {
        res.send('VIEWING ONE SHELTER')
    })

    router.get('/shelters/:id/edit', (req, res) => {
        res.send('EDITING ONE SHELTER')
    })

    module.exports = router;

    <span class="red">on index.js (main script for routes)</span>
    const express = require('express');
    const app = express();
    const <b>shelterRoutes</b> = require('./routes/shelters');

    app.use('/', <b>shelterRoutes</b>);

    app.listen(3000, () => {
        console.log('Serving app on localhost:3000')
    })
</code></pre>

<p>We can prefix the routes that begin with the same path:</p>

<pre><code>
    <span class="red">on /routes/shelters.js</span>
    const express = require('express');
    const router = express.Router();

    router.get('/', (req, res) => {
        res.send('ALL SHELTERS')
    })

    router.post('/', (req, res) => {
        res.send('CREATING A SHELTER')
    })

    router.get('/:id', (req, res) => {
        res.send('VIEWING ONE SHELTER')
    })

    router.get('/:id/edit', (req, res) => {
        res.send('EDITING ONE SHELTER')
    })

    module.exports = router;

    <span class="red">on index.js (main script for routes)</span>
    const express = require('express');
    const app = express();
    const <b>shelterRoutes</b> = require('./routes/shelters');

    app.use(<b>'/shelters', shelterRoutes</b>);

    app.listen(3000, () => {
        console.log('Serving app on localhost:3000')
    })
</code></pre>

<h4>mergeParams</h4>
<p>If we define a prefix that includes :id, in order to access req.params.id in the router, we have to add mergeParams option when calling Router function.</p>
<pre><code>
    <span class="red">on router .js</span>
    const router = express.Router({ mergeParams: true });
</code></pre>

<h4>Express Router & Middleware</h4>
<p>Middleware that are written or available inside of a router will only apply to this router's routes:</p>
<pre><code>
    <span class="red">on /routes/admin.js</span>
    const express = require('express');
    const router = express.Router();

    router.use((req, res, next) => {
        if (req.query.isAdmin) {
            next();
        }
        res.send('SORRY NOT AN ADMIN!')
    })

    router.get('/topsecret', (req, res) => {
        res.send('THIS IS TOP SECRET')
    })

    router.get('/deleteeverything', (req, res) => {
        res.send('OK DELETED IT ALL!')
    })

    <span class="red">on index.js</span>
    const adminRoutes = require('/routes/admin');
    app.use('/admin', adminRoutes);
</code></pre>

<h3>Cookies</h3>
<p>Cookies are little bits of information that are stored in a user's browser when browsing a particular website.</p>
<p>Once a cookie is set, a user's browser will send the cookie on every subsequent request to the site.</p>
<p>Cookies allow we to make HTTP stateful. Cookies are not used to store data, but for set a statefulness in the browser.</p>

<h4>Sending cookies</h4>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/greet', (req, res) => {
        res.send('hey there!')
    })

    app.get('/setname', (req, res) => {
        res.cookie('name', 'henrietta');
        res.send('OK, sent you a cookie!')
    })
    <span class="red">this route will set a cookie with key 'name' and value 'henrietta'</span>

    app.listen(3000, () => {
        console.log('SERVING!')
    })
</code></pre>

<h4>Parsing cookies: cookie parser middleware</h4>
<p>Once we have set cookies, whenever that user sends a request, the cookies object will be sent along with the request. In order to handle these cookies, in Express we have to install and require 'cookie-parser'. After routing <b>app.use(cookieParser())</b>, the property <b>req.cookies</b> will be available on all script as a JS object.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i cookie-parser

    <span class="red">on index.js</span>
    const cookieParser = require('cookie-parser');
    app.use(cookieParser());

    app.get('/setname', (req, res) => {
        res.cookie('name', 'henrietta');
        res.send('OK, sent you a cookie!')
    })

    app.get('/greet', (req, res) => {
        const { name = 'anonymous' } = req.cookies;
        res.send(`Hey there, ${name}!`);
    })
</code></pre>

<h4>Signing cookies</h4>
<p>After the server sends a cookie to a client, the client might modify the cookie before sending it back to the server in a future request. Sometimes this is harmless, sometimes it can be required by the application, but sometimes it is important that the cookie sent by the client is unchanged from its original server-defined value. (Imagine a cookie that contains a username or a bank account number or a monetary amount or a game score. Tampering with those could breach server security or allow some sort of theft or cheating.)
<br>
If the server needs to be able to detect that a cookie has not been changed by the client, the server can include a signature as part of the cookie, along with the actual cookie data that needs to be protected. The signature is derived from the cookie data and from a secret that is known only to the server. The secret makes it very difficult for a client that modifies the data to produce the correct signature to go along the modified data. A cookie with this kind of signature is what the cookie-parser module calls a signed cookie.
<br>
When a signed cookie is sent back to the server, the server can verify that the signature and the data in the cookie match each other. If they match then the server can be confident that the data is genuine. If they don't match then the server knows that the cookie has been modified by the client and the server can reject the request.
<br>    
So, you would use a signed cookie if you want assurance that the data being returned in the cookie has not been modified by the client. If the data in the cookie is not valuable and you don't care if it gets modified by the client, or if you have arranged to use some alternative mechanism to validate the contents of the cookie, then you don't need to use a signed cookie.
<br>
Note that simply signing cookies does not defend against all of the ways a client might try to trick a server. In particular, signing does not defend against replay attacks. Also note that it's a really bad idea for a server to send sensitive data to a client at all. The example I gave of putting a bank account number into a cookie was just to illustrate the concept. That's not something that a real web application should do.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.use(cookieParser(<b>'thisismysecret'</b>)); <span class="red">specifying a secret</span>
    
    app.get('/setsignedcookie', (req, res) => {
        res.cookie('fruit', 'grape',<b> { signed: true }</b>);<span class="red">sending a signed cookie</span>
        res.send('Ok signed your fruit cookie')
    })

    app.get('verifyfruit', (req, res) => {
        res.send(<b>req.signedCookies</b>);
    })
</code></pre>

<h3>Sessions</h3>
<p>It's not very practical (or secure) to store a lot of data client-side using cookies. This is where sessions come in!</p>
<p>Sessions are a server-side data store that we use to make HTTP stateful. Instead of storing data using cookies, we store the data on the server-side and then send the browser a cookie that can be used to retrieve the data.</p>
<p>In Express, we can work with sessions by using the 'express-session' package. It will send on each response a cookie with a property called <b>connect.sid</b> (session ID), which will identify this session. The object <b>req.session</b> will also be available.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i express-session
    
    <span class="red">on index.js</span>
    const session = require('express-session');

    app.use(session({secret: 'thisisnotagoodsecret'}));

    app.('/viewcount' (req, res) => {
        if (req.session.count) {
            req.session.count += 1;
        } else {
            req.session.count = 1;
        }
        res.send(`YOU HAVE VIEWED THIS PAGE ${req.session.count} TIMES`)
    })
</code></pre>

<p>Setting session options:</p>
<pre><code>
    const sessionOptions = { secret: 'thisisnotagoodsecret', resave: false, saveUninitialized: false };
    <span class="red">set resave and saveUninitialized like this if you get any deprecation warning</span>
    app.use(session(sessionOptions));
</code></pre>

<h3>Flash messages</h3>
<p>The flash is a special area of the session used for storing messages. Messages are written to the flash and cleared after being displayed to the user. The flash is typically used in combination with redirects, ensuring that the message is available to the next page that is to be rendered.</p>
<p>Flash messages are stored in the session. First, setup sessions as usual by enabling cookieParser and session middleware. Then, use flash middleware provided by connect-flash.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i connect-flash

    <span class="red">on index.js</span>
    const session = require('express-session');
    const flash = require('connect-flash');

    const sessionOptions = { secret: 'thisisnotagoodsecret', resave: false, saveUninitialized: false };
    app.use(session(sessionOptions));
    app.use(flash());
</code></pre>
<p>With the flash middleware in place, all requests will have a req.flash() function that can be used for flash messages.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.post('/farms', async (req, res) => {
        const farm = new Farm(req.body);
        await farm.save();
        <b>req.flash('success', 'Successfully made a new farm!');</b>
        res.redirect('/farms')
    })

    app.get('/farms', async (req, res) => {
        const farms = await Farm.find({});
        res.render('farms/index', { farms,<b> messages: req.flash('success') </b>});
    })

    <span class="red">on index.ejs (the template for the redirect target)</span>
    <%= messages %>
    < h1>
        All Farms
    </ h1>
</code></pre>

<h4>Creating a middleware to make things easier</h4>
<p>In order to simplify the passing-through of flash messages, we can create a middleware that uses res.locals, which is a property available on every response.</p>
<p>This middleware allows us to avoid writing <b>messages: req.flash('success')</b> everytime we have to pass a message to a template. By using this middleware, we can pass only the variable <b>messages</b>.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.use((req, res, next) => {
        res.locals.messages = req.flash('success');
        next();
    })

    app.get('/farms', async (req, res) => {
        const farms = await Farm.find({});
        res.render('farms/index', { 'farms' })
    }) <span class="red">now I don't have to pass messages anymore; messages will be available on every response</span>

    <span class="red">on index.ejs (the template for the redirect target)</span>
    <%= messages %> <span class="red">same as before!</span>
    < h1>
        All Farms
    </ h1>
</code></pre>

<h3>Authentication</h3>
<p>Here is what we need to learn authentication from scratch. But in practice, what we actually to is to make use of a package called 'Passport'.</p>

<h4>Authentication vs. Authorization</h4>
<p><b>Authentication</b> is the process of verifying who a particular user is. We typically authenticate with a username/password combo, but we can also use security questions, fingerprints, facial recognition, etc.</p>
<p><b>Authorization</b> is verifying what a specific user has access to. Generally, we authorize after a user has been authenticated: "now that we know who you are, here is what you are allowed to do and NOT allowed to do".</p>

<h4>How to (not) store passwords</h4>
<ol>
    <li>Never store passwords in db. SOLUTION: Hashing. Rather than storing a password in the database, we run the password through a <b>hashing function</b> first and then store the result in the database. Hashing functions are functions that map input data of some arbitrary size to fixed-size output values.</li>
</ol>

<h4>Cryptographic Hashing Functions</h4>
<ul>
    <li>One-way function which is infeasible to invert</li>
    <li>Small change in output yields large change in the output</li>
    <li>Deterministic - same input yields same output</li>
    <li>Unlikely to find 2 outputs with same value</li>
    <li>Password Hash Functions are deliberately SLOW</li>
</ul>

<h4>Salts: an extra safeguard</h4>
<p>Salting is an extra step to avoid reverse-engineering of our passwords.</p>
<p>A salt is a random value added to the password before we hash it. It helps ensure unique hashes and mitigate common attacks.</p>

<h4>Bcrypt: our hash function!</h4>
<p>After installing Bcrypt (npm i bcrypt), these are some methods that are frequently used:</p>
<pre><code>
    const bcrypt = require('bcrypt');

    const hashPassword = async (pw) => {
        const salt = await bcrypt.genSalt(12);
        const hash = await bcrypt.hash(pw, salt);
        console.log(salt);
        console.log(hash);
    }
    <span class="red"><b>12</b> is the number of rounds taken to generate the salt;
    the more rounds, the more difficult to hack. 12 is a good number, too high numbers will increase significantly the amount of delay</span>
    hashPassword('monkey');
</code></pre>
<p>We can also generate the salt and hash the password in one single step:</p>
<pre><code>
    const hashPassword = async (pw) => {
        const hash = await bcrypt.hash(pw, 12);
        console.log(hash);
    }
    hashPassword('monkey');
</code></pre>
<p>Comparing a plain password from input to a hashed password:</p>
<pre><code>
    const login = async (pw, hashedPw) => {
        const result = await bcrypt.compare(pw, hashedPw);
        if (result) {
            console.log('SUCCESSFULLY LOGGED IN!')
        } else {
            console.log('TRY AGAIN!')
        }
    }
    login('monkey', '478378y73ghdu3hbduoi2nbud3ou2dnil2u39h298');
</code></pre>

<h4>Writing auth from scratch</h4>
<p>1. Setup</p>
<pre><code>
    <span class="red">on models/user.js</span>
    const mongoose = require('mongoose');

    const userSchema = new mongoose.Schema({
        username: {
            type: String,
            required: [true, 'Username cannot be blank']
        },
        password: {
            type: String, <span class="red">hashed password!</span>
            required: [true, 'Password cannot be blank']
    });

    module.exports = mongoose.model('User', userSchema);

    <span class="red">on index.js</span>
    const express = require('express');
    const app = express();
    const User = require('./models/user')

    app.set('view engine', 'ejs');
    app.set('views', 'views');

    app.get('/register', (req, res) => {
        res.render('register');
    })

    app.get('/secret', (req, res) => {
        res.send('THIS IS SECRET! You cannot see me unless you are logged in.')
    })

    app.listen(3000, () => {
        console.log('SERVING YOUR APP!')
    })

    <span class="red">on register.ejs</span>
    < h1>Sign up form</>
    < form action="">
        < div>
            < label for="username">Enter username: < form /label>
            < input type="text" name="username" id="username" placeholder="username">
        </ div>
        < div>
            < label for="password">Enter password: < /label>
            < input type="password" name="password" id="password" placeholder="password">
        < /div>
        < button>Sign up< /button>
    < /form>
</code></pre>
<p>2. Registering (saving new user to db)</p>
<pre><code>
    <span class="red">on index.js</span>
    const mongoose = require('mongoose');
    const bcrypt = require('bcrypt');
    
    mongoose.connect('mongodb://localhost:27017/authDemo')
        .then(() => {
            console.log('Mongo connection open!');
        })
        .catch(() => {
            console.log('Mongo connection error!');
            console.log(err);
        })

    app.use(express.urlencoded({ extended: true }));
    <span class="red">(parse the req.body from post requests)</span>
    
    app.post('/register', async (req, res) => {
        <b>const { password, username } = req.body;
        const hash = await bcrypt.hash(password, 12);
        const user = new User({
            username,
            password: hash
        });
        await user.save();
        res.redirect('/');
        </b>
    })

    app.get('/', (req, res) => {
        res.send('This is the home page');
    })

    <span class="red">on register.ejs</span>
    < form action="/register" method="POST">< /form>
</code></pre>
<p>3. Login (comparing input to stored hashed password):</p>
<pre><code>
    <span class="red">on index.js</span>
    app.get('/login', (req, res) => {
        res.render('login')
    })

    app.post('/login', async (req, res) => {
        const { username, password } = req.body;
        const user = await User.findOne({ username: username });
        const validPassword = bcrypt.compare(password, user.password);
        if(validPassword){
            res.send('WELCOME!');
        } else {
            res.send('TRY AGAIN!');
        }
    })

    <span class="red">on login.ejs</span>
    < h1>Login</>
    < form action="/login" method="POST"><span class="red">use POST in order to avoid sending password as a query-string</span>
        < div>
            < label for="username">Enter username: < form /label>
            < input type="text" name="username" id="username" placeholder="username">
        </ div>
        < div>
            < label for="password">Enter password: < /label>
            < input type="password" name="password" id="password" placeholder="password">
        < /div>
        < button>Sign up< /button>
    < /form>
</code></pre>

<p>4. Staying logged in with session</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i express-session

    <span class="red">on index.js</span>
    const session = require('express-session');
    app.use(session({ secret: 'notagoodsecret' }));

    app.post('/login', async (req, res) => {
        const { username, password } = req.body;
        const user = await User.findOne({ username: username });
        const validPassword = bcrypt.compare(password, user.password);
        if(validPassword){
            <b>req.session.user_id = user._id;</b>
            res.send('WELCOME!');
        } else {
            res.send('TRY AGAIN!');
        }
    })

    app.post('/register', async (req, res) => {
        const { password, username } = req.body;
        const hash = await bcrypt.hash(password, 12);
        const user = new User({
            username,
            password: hash
        });
        await user.save();
        <b>req.session.user_id = user._id;</b>
        res.redirect('/');
    })

    app.get('/secret', (req, res) => {
        <b>if(!req.session.user_id){
            res.redirect('/login');
        }</b>
        res.send('THIS IS SECRET! You cannot see me unless you are logged in.')
    }) <span class="red">only logged users have access to '/secret'</span>
</code></pre>

<p>5. Implementing log-out functionality:</p>
<p>All that is needed to do is to remove user_id off the session, setting it to null.</p>
<pre><code>
    <span class="red">on index.js</span>
    app.post('/logout', (req, res) => {
        req.session.user_id = null;
        res.redirect('/login');
    })

    <span class="red">alternative way: destroying session:</span>
    app.post('/logout', (req, res) => {
        req.session.destroy();
        res.redirect('/login');
    })

    <span class="red">on other pages</span>
    < form action="/logout" method="POST">
        < button>Sign Out< /button>
    < /form>
</code></pre>

<p>EXTRA: a middleware to require login</p>
<pre><code>
    <span class="red">on index.js</span>
    const requireLogin = (req, res, next) => {
        if(!req.session.user_id) {
            return res.redirect('/login');
        }
        next();
    }

    app.get('/secret', requireLogin, (req, res) => {
        res.send('THIS IS SECRET! You cannot see me unless you are logged in.')
    }) 
</code></pre>

<p>EXTRA2: adding an authentication method to the User model</p>
<pre><code>
    <span class="red">on models/user.js</span>
    const bcrypt = require('bcrypt');
    
    const userSchema = new mongoose.Schema({
        username: {
            type: String,
            required: [true, 'Username cannot be blank']
        },
        password: {
            type: String,
            required: [true, 'Password cannot be blank']
    });

    userSchema.statics.findAndValidate = async function(username, password) {
        const foundUser = await this.findOne({ username });
        const isValid = await bcrypt.compare(password, foundUser.password);
        return isValid ? foundUser : false;
    }

    <span class="red">on index.js</span>
    app.post('/login', async (req, res) => {
        const { username, password } = req.body;
        const foundUser = await User.findAndValidate(username, password);
        if(foundUser){
            req.session.user_id = foundUser._id;
            res.send('WELCOME!');
        } else {
            res.send('TRY AGAIN!');
        }
    })
</code></pre>

<p>EXTRA2: adding an hash-password method to the User model</p>
<p>This middleware will hash a password before a new user is saved to the database.</p>
<pre><code>
    <span class="red">on models/user.js</span>
    userSchema.pre('save', async function(next) {
        if(!this.isModified('password')) return next(); <span class="red">if the pw hasn't been modified, then next.</span>
        this.password = await bcrypt.hash(this.password, 12);
        next();
    })

    <span class="red">on index.js</span>
    app.post('/register', async (req, res) => {
        const { password, username } = req.body;
        const user = new User({ username, password });
        await user.save();
        req.session.user_id = user._id;
        res.redirect('/');
    })
</code></pre>

<h3>Authentication using Passport</h3>
<p>It is important to know how to make auth from scratch, in order to understand each step that it envolves. But in real life we usually use packeges like Passport, which "hide" parts of this process and make it more simple. Colt Section 51, lecture 509. Working on Yelpcamp project.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i passport passport-local passport-local-mongoose 

    <span class="red">on models/user.js</span>
    const mongoose = require('mongoose');
    const Schema = mongoose.Schema;
    const passportLocalMongoose = require('passport-local-mongoose');

    const UserSchema = new Schema({
        email: {
            type: String,
            required: true,
            unique: true
        }
    });

    UserSchema.plugin(passportLocalMongoose);
    <span class="red">it's not necessary to define username or password, 
    because connecting to Passport will create them for us.
    </span>

    module.exports = mongoose.model('User', UserSchema);
</code></pre>

<p>Configuring Passport in app.js:</p>
<pre><code>
    <span class="red">on app.js</span>
    const passport = require('passport');
    const localStrategy = require('passport-local');
    const User = require('./models/user');

    app.use(passport.initialize());
    app.use(passport.session());
    <span class="red">passport.session() must be called after we call the regular app.use(session('secret')</span>
    passport.use(new localStrategy(User.authenticate()));
    
    passport.serializeUser(User.serializeUser());
    passport.deserializeUser(User.deserializeUser());
    <span class="red">these ones tell how Passport will add/remove user from session</span>

    <span class="red">hardcoding a new user:</span>
    app.get('/fakeUser', async (req, res) => {
        const user = new User({ email: 'colttt@gmail.com', username: 'colttt' });
        <span class="red">don't pass pw here</span>
        const newUser = await User.register(user, 'chicken'); <span class="red">the pw is 'chicken'</span>
        res.send(newUser);
    })
</code></pre>
<p>Registering a user with Passport:</p>
<pre><code>
    <span class="red">on routes/user.js</span>
    const express = require('express');
    const router = express.Router();
    const passport = require('passport');
    const catchAsync = require('../utils/catchAsync');
    const User = require('../models/user');

    router.get('/register', (req, res) => {
        res.render('users/register');
    });

    router.post('/register', catchAsync(async(req, res) => {
        try {
        const { email, username, password } = req.body;
        const user = new User({email, username});
        const registeredUser = await User.register(user, password);
        req.flash('success', 'Welcome to Yelp Camp!');
        res.redirect('/campgrounds');
        } catch(e) {
            req.flash('error', e.message);
            res.redirect('register');
        }
    }));

    module.exports = router;

    <span class="red">on views/users/register.ejs</span>
    <% layout('layouts/boilerplate') %>

    < h1>Register< /h1>
    < form action="/register" method="POST" class="validated-form" novalidate>
        < div class="mb-3">
            < label class="form-lable" for="username">Username: < /label>
            < input class="form-control" type="text" name="username" id="username" required>
            < div class="valid-feedback">Looks good!< /div>
        < /div>
        < div class="mb-3">
            < label class="form-lable" for="email">E-mail: < /label>
            < input class="form-control" type="email" name="email" id="email" required>
            < div class="valid-feedback">Looks good!< /div>
        < /div>
        < div class="mb-3">
            < label class="form-lable" for="password">Password: < /label>
            < input class="form-control" type="password" name="password" id="password" required>
            < div class="valid-feedback">Looks good!< /div>
        < /div>
        < button class="btn btn-success">Register< /button>
    < /form>
</code></pre>

<p>Login with Passport:</p>
<pre><code>
    <span class="red">on routes/user.js</span>
    router.get('/login', (req, res) => {
        res.render('users/login')
    })
    
    router.post('/login', passport.authenticate('local', { failureFlash: true, failureRedirect: '/login' }), (req, res) => {
        req.flash('success', 'Welcome back!');
        res.redirect('/campgrounds');
    })

    <span class="red">on views/users/login.ejs</span>
    <% layout('layouts/boilerplate') %>

    < h1>Login< /h1>
    < form action="/login" method="POST" class="validated-form" novalidate>
        < div class="mb-3">
            < label class="form-lable" for="username">Username: < /label>
            < input class="form-control" type="text" name="username" id="username" required>
            < div class="valid-feedback">Looks good!< /div>
        < /div>
        
        < div class="mb-3">
            < label class="form-lable" for="password">Password: < /label>
            < input class="form-control" type="password" name="password" id="password" required>
            < div class="valid-feedback">Looks good!< /div>
        < /div>
        < button class="btn btn-success">Login< /button>
    < /form>
</code></pre>

<p>3. isLoggedIn Middleware. We can create a middleware that uses the <b>isAuthenticated()</b> method (of Passport) to see if an user is logged in before letting him in; if not, redirect him to login page.</p>
<pre><code>
    <span class="red">on middleware.js</span>
    module.exports.isLoggedIn = (req, res, next) => {
        if (!req.isAuthenticated()) {
            req.flash('error', 'You must be signed in!');
            return res.redirect('/login');
        }
        next();
    }

    <span class="red">on routes/campgrounds.js</span>
    const { isLoggedIn } = require('../middleware');

    router.get('/new', isLoggedIn, (req, res) => {
        res.render('campgrounds/new');
    })

</code></pre>

<p>4. Logging out user.</p>
<p>Passport contains a method called req.logout() that accepts a callback function to handle errors.</p>
<pre><code>
    <span class="red">on users.js</span>
    router.get('/logout', (req, res, next) => {
        req.logout(function(err) {
          if (err) { return next(err); }
          req.flash('success', "Goodbye!");
          res.redirect('/campgrounds');
        });
      }); 

      <span class="red">adding a link on layouts/navbar.ejs</span>
      < div class="navbar-nav ms-auto">
        < a href="/login" class="nav-link">Login< /a>
        < a href="/register" class="nav-link">Register< /a>
        < a href="/logout" class="nav-link">Logout< /a>
      < /div>
</code></pre>

<p>5. currentUser helper</p>
<p>In order to see the username of the logged user, Passport provides a req.user property on the req object.</p>
<pre><code>
    <span class="red">on app.js</span>
    app.use((req, res, next) => {
        <b>res.locals.currentUser = req.user;</b>
        res.locals.success = req.flash('success');
        res.locals.error = req.flash('error');
        next();
    })
    <span class="red">res.locals is used to define info that we want to be available on every template we go</span>

    <span class="red">adjusting layouts/navbar.ejs to only show logout if the user is logged in and vice-versa</span>
    <div class="navbar-nav ms-auto">
        <% if(!currentUser) { %>
        < a href="/login" class="nav-link">Login< /a>
        < a href="/register" class="nav-link">Register< /a>
        <% } else { %>
        < a href="/logout" class="nav-link">Logout< /a>
        <% } %>
      < /div>
</code></pre>

<p>6. Automatically logging in when user registers:</p>
<p>Here we can make use of the Passport method <b>login()</b>, which also requires a catch error callback function.</p>
<p>What's the difference between <b>passport.authenticate()</b> and <b>req.login()</b>? The first will <i>compare</i> a provided pw with the hashed pw on out db; the second will login an user that was just created.</p>
<pre><code>
    <span class="red">on routes/users.js</span>
    router.post('/register', catchAsync(async(req, res, next) => {
        try {
        const { email, username, password } = req.body;
        const user = new User({email, username});
        const registeredUser = await User.register(user, password);
        <b>req.login(registeredUser, err => {
            if(err) return next(err);
            req.flash('success', 'Welcome to Yelp Camp!');
            res.redirect('/campgrounds');
        })</b>
        } catch(e) {
            req.flash('error', e.message);
            res.redirect('register');
        }
    }));
</code></pre>

<p>7. Returning to the page that the user originally wanted to go, after login:</p>
<pre><code>
    <span class="red">on middleware.js</span>
    module.exports.isLoggedIn = (req, res, next) => {
        if (!req.isAuthenticated()) {
            <b>req.session.returnTo = req.originalUrl;</b>
            req.flash('error', 'You must be signed in!');
            return res.redirect('/login');
        }
        next();
    }

    <span class="red">on routers/users.js</span>
    router.post('/login', passport.authenticate('local', { failureFlash: true, failureRedirect: '/login', <b>keepSessionInfo: true</b> }), (req, res) => {
        req.flash('success', 'Welcome back!');
        <b>const redirectUrl = req.session.returnTo || '/campgrounds';
        delete req.session.returnTo;
        res.redirect(redirectUrl);</b>
    })
</code></pre>

<h3>Authorization using Passport</h3>
<p>Authorization will allow us to associate each item (new campground, review etc) to a specific user (author); only this user will be allowed to edit or delete these items. Colt section 52, lecture 520, working on Yelpcamp project.</p>

<p>1. Adding an author to campgrounds</p>
<pre><code>
    <span class="red">on models/campground.js</span>
    const CampgroundSchema = new Schema({
        title: String,
        image: String,
        price: Number,
        description: String,
        location: String,
        <b>author: {
            type: Schema.Types.ObjectId,
            ref: 'User'
        },</b>
        reviews: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Review'
            }
        ]
    });
</code></pre>

<p>2. Re-seeding the database, so that every campground has an author:</p>
<pre><code>
    <span class="red">on seeds/index.js</span>
    const seedDB = async() =>{
        await Campground.deleteMany({});
        for(let i = 0; i < 50; i++){
            const random1000 = Math.floor(Math.random() * 1000);
            const price = Math.floor(Math.random() * 20) + 10;
            const camp = new Campground({ 
                <b>author: '632258fd8d8c482a706a8c71',</b>
                location: `${cities[random1000].city}, ${cities[random1000].state}`, title: `${sample(descriptors)} ${sample(places)}`, 
                image: 'https://source.unsplash.com/collection/483251', 
                description: 'Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium vero qui dolorum eius voluptate ipsam tenetur corporis, veniam, tempora quaerat voluptas ducimus? Necessitatibus molestias totam magnam officiis, dolorem quaerat debitis.', 
                price: price})
            await camp.save();
        };
    }
    <span class="red">that is the _id of user <b>gloriagroove</b></span>
</code></pre>

<p>3. Showing the author on campground's details page template:</p>
<pre><code>
    <span class="red">on routes/campgrounds.js</span>
    router.get('/:id', catchAsync(async (req, res) => {
        const campground = await (await Campground.findById(req.params.id).populate('reviews'))<b>.populate('author');</b>
        if(!campground){
            req.flash('error', 'Sorry, campground not found');
            return res.redirect('/campgrounds');
        }
        res.render('campgrounds/show', {campground})
    }))

    <span class="red">on show.ejs</span>
        < li class="list-group-item text-muted"><%= campground.location %>< /li>
        <b>< li class="list-group-item">Submitted by <%= campground.author.username %>< /li></b>
        < li class="list-group-item">$<%= campground.price%>/night< /li>

    <span class="red">on routes/campgrounds.js (defining the author of a new campground)</span>
    router.post('/', isLoggedIn, validateCampground, catchAsync(async (req, res, next) => {
        const campground = new Campground(req.body.campground);
        <b>campground.author = req.user._id;</b>
        await campground.save();
        req.flash('success', 'Successfully made a new campground!');
        res.redirect(`/campgrounds/${campground._id}`);
    }))
</code></pre>

<p>4. Showing/hiding the Edit and Delete buttons (so that only the author can edit and delete his own items):</p>
<pre><code>
    <span class="red">on show.ejs</span>
    <% if(currentUser && campground.author.equals(currentUser)) { %>
        < div class="card-body">
            < a href="/campgrounds/<%=campground._id%>/edit" class="card-link btn btn-info">Edit< /a>
            < form class="d-inline" action="/campgrounds/<%=campground._id%>?_method=DELETE" method="POST">
                < button class="btn btn-danger">Delete< /button>
            < /form>
        < /div>
        <% } %>

    <span class="red">to prevent the users to make prohibited changes using put/delete requests, we have to protect the routes on routes/campgrounds.js</span>
    router.put('/:id', isLoggedIn,validateCampground, catchAsync(async (req, res) => {
        const { id } = req.params;
        <b>const campground = await Campground.findById(id);
        if(!campground.author.equals(req.user._id)) {
            req.flash('error', 'You do not have permission to do that.');
            return res.redirect(`/campgrounds/${id}`);
        }</b>
        const camp = await Campground.findByIdAndUpdate(id, { ...req.body.campground });
        req.flash('success', 'Successfully updated campground');
        res.redirect(`/campgrounds/${campground._id}`)
    }))

    <span class="red">in order to add this code to other routes, it's better to create a middleware:</span>
    const isAuthor = async (req, res, next) => {
        const { id } = req.params;
        const campground = await Campground.findById(id);
        if (!campground.author.equals(req.user._id)) {
            req.flash('error', 'You do not have permission to do that.');
            return res.redirect(`/campgrounds/${id}`);
        }
    }

    <span class="red">it's always good to put all middlewares in middleware.js file, so that the routes files stays clean.</span>

</code></pre>

<h3>Refactoring our routes: MVC Architecture Pattern</h3>
<p>MVC (Model-View-Controller) is an architecture pattern that is largely used in medium/large scale apps.</p>
<p>Up to this point, we already have the Models folder (with the Schemas and its models) and the Views folder (with all .ejs view files).</p>
<p>For the sake of organization and cleaness, now we are going to create a Controllers folder, where we will store the core functions of our routes. Then the routes will only have to require and call these functions.</p>
<pre><code>
    <span class="red">on routes/campgrounds.js</span>
    const campgrounds = require('../controllers/campgrounds');

    router.get('/', catchAsync(campgrounds.index));
    <span class="red">'index' is a function (method) found on the campgrounds object, that was imported from ../controllers/campgrounds.js</span>

    <span class="red">on controllers/campgrounds.js</span>
    const Campground = require('../models/campground');

    module.exports.index = async (req, res) => {
        const campgrounds = await Campground.find({});
        res.render('campgrounds/index', { campgrounds })
    }
</code></pre>
<p>To refactor our routes, we do the above process to each and every route. Always remember to require in the controller all of the methods/objects/scripts that each of the functions uses.</p>

<h3>Refactoring our routes II: router.route(< path >)</h3>
<p>We can use <b>router.route(path)</b> to compile all routes that target the same path. For example:</p>
<pre><code>
    <span class="red">on routes/campgrounds.js, BEFORE:</span>
    router.get('/', catchAsync(campgrounds.index));

    router.post('/', isLoggedIn, validateCampground, catchAsync(campgrounds.createCampground))

    <span class="red">AFTER:</span>
    router.route('/')
        .get(catchAsync(campgrounds.index))
        .post(isLoggedIn, validateCampground, catchAsync(campgrounds.createCampground));
</code></pre>

<h3>Image upload</h3>
<p>Up to this point, all of our req.body objects are coming parsed into url. This is because we originally set on app.js the following route: <b>app.use(express.urlencoded({extended: true}));</b>.</p>
<p>So, the first thing that we have to do is change the encoding type in the form html-element in which our image upload input will be written: </p>
<pre><code>
    <span class="red">on views/campgrounds/new.ejs</span>
    < form action="/campgrounds" method="POST" novalidate class="validated-form" <b>enctype="multipart/form-data"</b>>< /form>

    < input type="file" name="image" id="">
    <span class="red">this will create a "choose file" input on our form</span>
</code></pre>

<p>In order to parse the <b>multipart</b> req.body, we have to install and require a middleware called <b>Multer</b>.</p>
<p>Multer adds a body object and a file or files object to the request object. The body object contains the values of the text fields of the form, the file or files object contains the files uploaded via the form. Multer Docs: https://github.com/expressjs/multer</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i multer 

    <span class="red">on routes/campgrounds.js</span>
    const multer = require('multer');
    const upload = multer({ dest: 'uploads/' });

    .post(upload.single('image'), (req, res) => {
        console.log(req.body, req.file)
    })
</code></pre>
<p>Through upload.single('name_of_input'), Multer will parse one <b>req.file</b> for the image file, and one <b>req.body</b> for the rest of the information from that form (other fields like location, title, price, description, etc.)</p>
<p>In order to upload multiple files at once, wo to as follows:</p>
<pre><code>
    <span class="red">on views/campgrounds/new.ejs</span>
    < form action="/campgrounds" method="POST" novalidate class="validated-form" enctype="multipart/form-data" <b>multiple</b>>< /form>

    <span class="red">on routes/campgrounds.js</span>
    const multer = require('multer');
    const upload = multer({ dest: 'uploads/' });

    .post(upload.<b>array</b>('image'), (req, res) => {
        console.log(req.body, <b>req.files</b>)
    })
</code></pre>
<p>Next up, in order to store our image files on the cloud, we can create a Cloudinary account. We will receive an unique API key, then to handle this API key in our app we must use <b>.env</b> files and a package called <b>dovenv</b> to handle them. </p>
<p>So, first, create a .env file in your project's root.</p>
<pre><code>
    <span class="red">on Terminal</span>
    npm i dotenv 

    <span class="red">on .env</span>
    API_KEY=763782yehg8yhdoyuhoe87272

    <span class="red">on top of app.js</span>
    if (process.env.NODE_ENV !== 'production') {
        require('dotenv').config();
    }
    <span class="red">this will handle .env files while we are on development stage. 
    later on we will learn how to handle this information on production stage.
    </span>
    <span class="red">* now the information stored on .env is available in our environment, for example:
        console.log(process.env.API_KEY);
    </span>
</code></pre>
<P>Now, in order to store files on Cloudinary directly from our forms, we'll use a tool called <b>multer-storage-cloudinary</b>.</P>
<pre><code>
    <span class="red">on Terminal</span>
    npm i cloudinary multer-storage-cloudinary 

    <span class="red">create a 'cloudinary' folder</span>
    
    <span class="red">on cloudinary/index.js</span>
    const cloudinary = require('cloudinary').v2;
    const { CloudinaryStorage } = require('multer-storage-cloudinary');

    cloudinary.config({
        cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
        api_key: process.env.CLOUDINARY_KEY,
        api_secret: process.env.CLOUDINARY_SECRET
    });

    const storage = new CloudinaryStorage({
        cloudinary,
        folder: 'YelpCamp',
        <span class="red">this is the name of the folder on Cloudinary Cloud</span>
        allowedFormats: ['jpeg', 'png', 'jpg']
    })

    module.exports = {
        cloudinary,
        storage
    }

    <span class="red">on routes/campgrounds.js</span>
    const { storage } = require('../cloudinary');
    const upload = multer({ storage });
    <span class="red">change where the img files are stored to our Cloudinary storage</span>

    router.route('/')
    .get(catchAsync(campgrounds.index))
    .post(upload.array('image'), (req, res) => {
        console.log(req.body, req.files);
        res.send('it worked!')
    })
</code></pre>
<p>The console.logged array 'req.files' will look like this:</p>
<pre><code>
    [
  {
    fieldname: 'image',
    originalname: 'yelpcamp_img1.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    path: 'https://res.cloudinary.com/dbru1wghw/image/upload/v1663532053/le79gzq0gp40notk660d.jpg',
    size: 127225,
    filename: 'le79gzq0gp40notk660d'
  },
  {
    fieldname: 'image',
    originalname: 'yelpcamp_img2.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    path: 'https://res.cloudinary.com/dbru1wghw/image/upload/v1663532053/oynelfxfbcg2qcryclpf.jpg',
    size: 169922,
    filename: 'oynelfxfbcg2qcryclpf'
  }
]
</code></pre>
<p>Storing image links (Cloudinary paths) to Mongo. First we have to update the model via CampgroundSchema:</p>
<pre><code>
    <span class="red">on models/campgrounds.js</span>
    const CampgroundSchema = new Schema({
        title: String,
        <b>images: [
            {
                url: String,
                filename: String
            }
        ],</b>
        price: Number,
        description: String,
        location: String,
        author: {
            type: Schema.Types.ObjectId,
            ref: 'User'
        },
        reviews: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Review'
            }
        ]
    });

    <span class="red">update route on routes/campgrounds.js</span>
    router.route('/')
    .get(catchAsync(campgrounds.index))
    .post(isLoggedIn, upload.array('image'), validateCampground, catchAsync(campgrounds.createCampground));

    <span class="red">update 'createCampground' function on controllers/campgrounds.js</span>
    module.exports.createCampground = async (req, res, next) => {
        const campground = new Campground(req.body.campground);
        campground.images = req.files.map(f => ({ url: f.path, filename: f.filename }));
        <span class="red">creates a new object for each item on array 'req.files'</span>
        campground.author = req.user._id;
        await campground.save();
        req.flash('success', 'Successfully made a new campground!');
        res.redirect(`/campgrounds/${campground._id}`);
    };
</code></pre>

<p>Adding Delete Images feature to edit form:</p>
<pre><code>
    <span class="red">on edit.ejs</span>
    < div class="mb-3">
        <% campground.images.forEach((img, i) => { %>
            < img src="<%=img.url%>" alt="" class="img-thumbnail">< div class="form-check-inline">
                < input type="checkbox" id="image-<%=i%>" name="deleteImages[]" value="<%=img.filename%>">< label for="image-<%=i%>"> Delete?< /label>
            < /div>
        <% }) %>
    < /div>
    <span class="red">each one of the checked values will be pushed into the array that id the value of the deleteImages property on req.body</span>

    <span class="red">on schemas.js</span>
    module.exports.campgroundSchema = Joi.object({
        campground: Joi.object({
            title: Joi.string().required(),
            price: Joi.number().required().min(0),
            // image: Joi.string().required(),
            location: Joi.string().required(),
            description: Joi.string().required()
        }).required()<b>,
        deleteImages: Joi.array()</b>
    })
    
    <span class="red">on controllers/campgrounds.js</span>
    module.exports.updateCampground = async (req, res) => {
        const { id } = req.params;
        const campground = await Campground.findByIdAndUpdate(id, { ...req.body.campground });
        const imgs = req.files.map(f => ({ url: f.path, filename: f.filename }));
        campground.images.push(...imgs);
        await campground.save();
        <b>if (req.body.deleteImages) {
            await campground.updateOne({ $pull: { images: { filename: { $in: req.body.deleteImages } } } });
            console.log(campground);
        };</b>
        req.flash('success', 'Successfully updated campground');
        res.redirect(`/campgrounds/${campground._id}`)
    };
    <span class="red">this will delete the images from db</span>

    <span class="red">on controllers/campgrounds.js</span>
    <b>const { cloudinary } = require("../cloudinary");</b>

    module.exports.updateCampground = async (req, res) => {
        const { id } = req.params;
        const campground = await Campground.findByIdAndUpdate(id, { ...req.body.campground });
        const imgs = req.files.map(f => ({ url: f.path, filename: f.filename }));
        campground.images.push(...imgs);
        await campground.save();
        <b>if (req.body.deleteImages) {
            for (let filename of req.body.deleteImages) {
                await cloudinary.uploader.destroy(filename);
            }
            await campground.updateOne({ $pull: { images: { filename: { $in: req.body.deleteImages } } } });
        };</b>
        req.flash('success', 'Successfully updated campground');
        res.redirect(`/campgrounds/${campground._id}`)
    };
    <span class="red">this will delete images from db AND from Cloudinary storage</span>
</code></pre>

<p>Adding thumbnails to delete images feature in edit.ejs, using Cloudinary transformation tools. Cloudinary features transformation tools which allow us to get an image with adjusted size, and a bunch of other adjustments.</p>
<p>https://res.cloudinary.com/dbru1wghw/image/upload/<b>w_200</b>/v1663706682/YelpCamp/ia7yipegv2ompfdo3bqa.png is the path to a 200px-wide version of that image.</p>
<p>In order to use this feature, we can add logic to our edit.ejs template to split this path and add <b>w_200</b> in the middle. In order to avoid adding too much logic to our template, another option is:</p>
<pre><code>
    <span class="red">on models/campgrounds.js</span>
    <b>const ImageSchema = new Schema({
        url: String,
        filename: String
    })

    ImageSchema.virtual('thumbnail').get(function() {
        return this.url.replace('/upload', '/upload/w_200');
    })</b>

    const CampgroundSchema = new Schema({
        title: String,
        images: <b>[ImageSchema]</b>,
        price: Number,
        description: String,
        location: String,
        author: {
            type: Schema.Types.ObjectId,
            ref: 'User'
        },
        reviews: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Review'
            }
        ]
    });
    <span class="red">instead of storing a new path for each image, we are creating a virtual (a method) in ImageSchema that will change the original path when it is called to do it.</span>

    <span class="red">on edit.ejs</span>
    < div class="mb-3">
        <% campground.images.forEach((img, i) => { %>
            < img src="<%=img.thumbnail%>" alt="" class="<b>img-thumbnail</b>">< div class="form-check-inline mb-3">
                < input type="checkbox" id="image-<%=i%>" name="deleteImages[]" value="<%=img.filename%>">< label for="image-<%=i%>"> Delete?< /label>
            < /div>
        <% }) %>
    < /div>
</code></pre>

<h3>Adding map: Mapbox</h3>
<p>After signing up for Mapbox, store the Mapbox token on .env file.</p>
<p>For geocoding, we could make direct API requests to Mapbox API, but instead of that, we are going to use @mapbox/mapbox-sdk node client.</p>
<pre><code>
    <span class="red">on .env</span>
    MAPBOX_TOKEN=pk.eyJ1Ijoidml0b3JqYWd1YXQiLCJhIjoiY2w4YzNhbW11MDMwMjN2bnRtb3I3d3VsZCJ9.puMAG2x0aRCow4aQmACz7A

    <span class="red">on Terminal</span>
    npm i @mapbox/mapbox-sdk

    <span class="red">on controllers/campgrounds.js</span>
    const mbxGeocoding = require('@mapbox/mapbox-sdk/services/geocoding');
    const mapBoxToken = process.env.MAPBOX_TOKEN;
    const geocoder = mbxGeocoding({ accessToken: mapBoxToken });
    
    module.exports.createCampground = async (req, res, next) => {
        const geoData = await geocoder.forwardGeocode({
            query: req.body.campground.location,
            limit: 1
        }).send();
        res.send(geoData.body.features[0].geometry.coordinates)
        <span class="red"></span>geoData.body.features[0].geometry will return a GeoJSON object. we have to format our CampgroundSchema accordingly to the strict parameters of this format:

    <span class="red">on models/campgrounds.js</span>
    const CampgroundSchema = new Schema({
        title: String,
        images: [ImageSchema],
        <b>geometry: {
            type: {
                type: String,
                enum: ['Point'],
                required: true
            },
            coordinates: {
                type: [Number],
                required: true
            }
        },</b>
        price: Number,
        description: String,
        location: String,
        author: {
            type: Schema.Types.ObjectId,
            ref: 'User'
        },
        reviews: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Review'
            }
        ]
    });

    <span class="red">the final code on controllers/campgrounda.js will look like this:</span>
    module.exports.createCampground = async (req, res, next) => {
        <b>const geoData = await geocoder.forwardGeocode({
            query: req.body.campground.location,
            limit: 1
        }).send();</b>
        const campground = new Campground(req.body.campground);
        <b>campground.geometry = geoData.body.features[0].geometry;</b>
        campground.images = req.files.map(f => ({ url: f.path, filename: f.filename }));
        campground.author = req.user._id;
        await campground.save();
        console.log(campground)
        req.flash('success', 'Successfully made a new campground!');
        res.redirect(`/campgrounds/${campground._id}`);
    };
</code></pre>

<h4>Displaying maps from Mapbox</h4>
<p>Mapbox's script and css will be integrated in boilerplate.ejs's head, so it can be available in all view pages.</p>
<pre><code>
    <span class="red">on boilerplate.ejs</span>
    < scri pt src='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js'>< /script>
    < link href='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css' rel='stylesheet' />

    <span class="red">on show.ejs</span>
    <span class="red">wherever we want to display the map:</span>
    < div id='map' style='width: 400px; height: 300px;'>< /div>
    <span class="red">on the bottom:</span>
    < scri pt>
        const mapToken = '<%-process.env.MAPBOX_TOKEN%>';
    < /script>
    < scri pt src="/javascripts/showPageMap.js">< /sc ript>

    <span class="red">on public/javascripts/showPageMap.js</span>
    mapboxgl.accessToken = mapToken;
    const map = new mapboxgl.Map({
        container: 'map', 
        style: 'mapbox://styles/mapbox/streets-v11', 
        center: [-75, 76], 
        zoom: 6
        });

    new mapboxgl.Marker()
        .setLngLat([-75, 76])
        .addTo(map) 
    <span class="red">this will add a Pin to the centered location</span>


</code></pre>

<h4>Centering a map on a campground</h4>
<p>After displaying the map, we can now center the map on the campground location.</p>
<pre><code>
    <span class="red">on show.ejs</span>
    < scri pt>
        const mapToken = '<%-process.env.MAPBOX_TOKEN%>';
        <b>const campground = <%- JSON.stringify(campground) %></b>
    < /script>
    < scri pt src="/javascripts/showPageMap.js">< /script>
    
    <span class="red">on showMapPage.js</span>
    mapboxgl.accessToken = mapToken;
    const map = new mapboxgl.Map({
        container: 'map', 
        style: 'mapbox://styles/mapbox/streets-v11', 
        center: <b>campground.geometry.coordinates</b>, 
        zoom: 6
        });

    new mapboxgl.Marker()
        .setLngLat(<b>campground.geometry.coordinates</b>)
        .addTo(map) 
</code></pre>

<h4>Adding a popup on Marker</h4>
<p>This feature adds a customizable popup that toggles when we click on the marker.</p>
<pre><code>
    new mapboxgl.Marker()
    .setLngLat(campground.geometry.coordinates)
    .setPopup(
        new mapboxgl.Popup({offset: 25})
        .setHTML(
            `< p>${campground.title}< /p>`
            <span class="red">HTML here</span>
        )
    )
    .addTo(map)
</code></pre>

<h4>Adding a Cluster Map into index page</h4>
<p>This feature adds a cluster map showing all maps in a given area on the index page. More at https://docs.mapbox.com/mapbox-gl-js/example/cluster/</p>
<pre><code>
    <span class="red">on views/campgrounds/index.ejs</span>
    < div id="map" style="width: 100%; height: 500px;">< /div>


    <span class="red">on public/javascripts/clusterMap.js</span>
    mapboxgl.accessToken = mapToken;
    const map = new mapboxgl.Map({
    container: 'map',
    <span class="red"> Choose from Mapbox's core styles, or make your own style with Mapbox Studio</span>
    style: 'mapbox://styles/mapbox/light-v10',
    center: [-103.5917, 40.6699],
    zoom: 3
    });
    
    map.on('load', () => {
    <span class="red"> Add a new source from our GeoJSON data and
     set the 'cluster' option to true. GL-JS will
     add the point_count property to your source data.</span>
    map.addSource('campgrounds', {
    type: 'geojson',
    <span class="red"> Point to GeoJSON data. This example visualizes all M1.0+ earthquakes
    // from 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program.</span>
    data: campgrounds,
    cluster: true,
    clusterMaxZoom: 14, <span class="red">// Max zoom to cluster points on</span>
    clusterRadius: 50 <span class="red"> Radius of each cluster when clustering points (defaults to 50)</span>
    });
    
    map.addLayer({
    id: 'clusters',
    type: 'circle',
    source: 'campgrounds',
    filter: ['has', 'point_count'],
    paint: {
    <span class="red"> Use step expressions (https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
    // with three steps to implement three types of circles:
    //   * Blue, 20px circles when point count is less than 100
    //   * Yellow, 30px circles when point count is between 100 and 750
    //   * Pink, 40px circles when point count is greater than or equal to 750</span>
    'circle-color': [
    'step',
    ['get', 'point_count'],
    '#51bbd6',
    10,
    '#f1f075',
    30,
    '#f28cb1'
    ],
    'circle-radius': [
    'step',
    ['get', 'point_count'],
    15, <span class="red">change the max limit number of items in a cluster and cluster sizes (px) here</span>
    10,
    20,
    30,
    25
    ]
    }
    });
    
    map.addLayer({
    id: 'cluster-count',
    type: 'symbol',
    source: 'campgrounds',
    filter: ['has', 'point_count'],
    layout: {
    'text-field': '{point_count_abbreviated}',
    'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
    'text-size': 12
    }
    });
    
    map.addLayer({
    id: 'unclustered-point',
    type: 'circle',
    source: 'campgrounds',
    filter: ['!', ['has', 'point_count']],
    paint: {
    'circle-color': '#11b4da',
    'circle-radius': 4,
    'circle-stroke-width': 1,
    'circle-stroke-color': '#fff'
    }
    });
    
    <span class="red">// inspect a cluster on click</span>
    map.on('click', 'clusters', (e) => {
    const features = map.queryRenderedFeatures(e.point, {
    layers: ['clusters']
    });
    const clusterId = features[0].properties.cluster_id;
    map.getSource('campgrounds').getClusterExpansionZoom(
    clusterId,
    (err, zoom) => {
    if (err) return;
    
    map.easeTo({
    center: features[0].geometry.coordinates,
    zoom: zoom
    });
    }
    );
    });
    
    <span class="red">// When a click event occurs on a feature in
    // the unclustered-point layer, open a popup at
    // the location of the feature, with
    // description HTML from its properties.</span>
    map.on('click', 'unclustered-point', (e) => {
    const coordinates = e.features[0].geometry.coordinates.slice();
    const mag = e.features[0].properties.mag;
    const tsunami =
    e.features[0].properties.tsunami === 1 ? 'yes' : 'no';
    
    <span class="red">// Ensure that if the map is zoomed out such that
    // multiple copies of the feature are visible, the
    // popup appears over the copy being pointed to.</span>
    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
    }
    
    new mapboxgl.Popup()
    .setLngLat(coordinates)
    .setHTML(
    `< h6>Campground< /h6>` <span class="red">html for popup here</span>
    )
    .addTo(map);
    });
    
    map.on('mouseenter', 'clusters', () => {
    map.getCanvas().style.cursor = 'pointer';
    });
    map.on('mouseleave', 'clusters', () => {
    map.getCanvas().style.cursor = '';
    });
    });
</code></pre>

<p>In order to allow Mapbox to show each campground's name and link on its specific point on the map, we have to provide an object with the properties "geometry" (object campground already has it) and "properties" (in which Mapbox will look for values to show in the popups, for example. So, we will add a virtual to the campground schema, so that "properties" stays available when needed.</p>
<p>By default, Mongoose does not include virtuals when you convert a document to JSON. For example, if you pass a document to Express' res.json() function, virtuals will not be included by default. To include virtuals in res.json(), you need to set the toJSON schema option to { virtuals: true }. We are stringifying our campground object on views/campgrounds/index.ejs, so we'll have to do it.</p>

<pre><code>
    <span class="red">in models/campgrounds.js</span>
    <b>const opts = { toJSON: { virtuals: true } };</b>

    const CampgroundSchema = new Schema({
        title: String,
        images: [ImageSchema],
        geometry: {
            type: {
                type: String,
                enum: ['Point'],
                required: true
            },
            coordinates: {
                type: [Number],
                required: true
            }
        },
        price: Number,
        description: String,
        location: String,
        author: {
            type: Schema.Types.ObjectId,
            ref: 'User'
        },
        reviews: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Review'
            }
        ]
    }<b>, opts</b>);
    
    <b>CampgroundSchema.virtual('properties.popUpMarkup').get(function() {
        return `
        < a href="/campgrounds/${this._id}">${this.title}< /a>
        < p>${this.description.substring(0,60)}...< /p>
        `
    });</b>

    <span class="red">on public/javascripts/clusterMap.js</span>
    map.on('click', 'unclustered-point', (e) => {
        const coordinates = e.features[0].geometry.coordinates.slice();
        const text = e.features[0].properties.popUpMarkup; <span class="red">here the virtual is being called</span>
        
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
         
        new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML(
        text <span>this will accept html; in our case the html is written as the value of e.features[0].properties.popUpMarkup</span>
        )
        .addTo(map);
        });
</code></pre>

<p>We can also add navigation controls to the map, by adding the following method:</p>
<pre><code>
    map.addControl(new mapboxgl.NavigationControl());
</code></pre>

<h3>Security issues</h3>
<h4>Mongo injection</h4>
<p>Mongo injection refers to the situation when a user uses the queries and req.body to <b>inject</b> malicious code into the app. In order to protect the app from this type of attack, we can make use of a package called <b>express-mongo-sanitize</b>, which can prevent some characters (like ; , &) to be submitted as part of query strings or req.body.</p>


<script src="app.js"></script>

</html>