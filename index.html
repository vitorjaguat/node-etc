<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node etc.</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Node etc.</h1>
    <p>Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on a JavaScript
        Engine (i.e. V8 engine) and executes JavaScript code outside a web browser, which was designed to build scalable
        network applications. Node.js lets developers use JavaScript to write command line tools and for server-side
        scriptingâ€”running scripts server-side to produce dynamic web page content before the page is sent to the user's
        web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application
        development around a single programming language, rather than different languages for server-side and
        client-side scripts.</p>
</body>
<h3>Running .js files using Node</h3>
<p>On the terminal:</p>
<pre><code>
    node firstScript.js
    <span class="red">the JS file will run inside the terminal</span>
</code></pre>
<h3>Process</h3>
<p>The process object is a global that provides information about, and control over, the current Node.js process. As a
    global, it is always available to Node.js applications without using require().</p>
<p>We can compare process to the window object on a browser.</p>
<h3>process.argv</h3>
<p>The process.argv property returns an array containing the command line arguments passed when the Node.js process was
    launched. The first element will be process.execPath. The process.execPath property returns the absolute pathname of
    the executable that started the Node.js process: usually '/usr/local/bin/node'. The second element will be the path
    to the JavaScript file being executed. The remaining elements will be any additional command line arguments.</p>
<pre><code>
    node firstScript.js puppies chickens hello
    <span class="red">these 3 strings will be added to the argv array.</span>
</code></pre>
<p>process.argv returns an array, and can be accessed from the js file.</p>

<h3>File System Module (fs)</h3>
<p>The fs module enables interacting with the file system. </p>
<p>All file system operations have synchronous, callback, and promise-based forms.</p>
<p>Unlike the process object, the fs module must be required before being used in the script.</p>
<p>Example: creating a script that creates boilerplates files (index.html, style.css, app.js) for a new project.</p>
<pre><code>
on script:
const fs = require('fs'); <span class="red">requires fs module</span>
const folderName = process.argv[2] || 'Project'; <span class="red">accesses the argument that was provided by the user</span>
fs.mkdirSync(folderName); <span class="red">creates a folder with the name provided by the user</span>
fs.writeFileSync(`${folderName}/index.html`, '');
fs.writeFileSync(`${folderName}/style.css`, '');
fs.writeFileSync(`${folderName}/app.js`, '')
<span class="red">creates these 3 files inside that folder. The second argument is the content of that file and can be set to empty.</span>

async version:
fs.mkdir(`${folderName}`, { recursive: true }, (err) => {
    console.log('The folder is successfully created')
    if (err) console.log(err);
 })
fs.writeFile(`${folderName}/index.html`, 'I am the new file\'s content', (err) => {
    console.log('The HTML file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/style.css`, 'I am the new file\'s content', (err) => {
    console.log('The CSS file is successfully created')
    if (err) console.log(err)
 });
 fs.writeFile(`${folderName}/app.js`, 'I am the new file\'s content', (err) => {
    console.log('The JS file is successfully created')
    if (err) console.log(err)
 });
 
on the command line:
node boilerplate.js Portfolio
<span class="red">creates a folder called Portfolio with those 3 files inside of it.</span>
</code></pre>

<h3>Exporting modules using module.export</h3>
<p>In order to create our own modules, the first thing to do is to put the value inside of module.exports object in the
    module's file.</p>
<p>Then we have to require the module using require('./moduleName') inside the file where we want to use it.</p>
<pre><code>
    on the module:
    module.exports.sum = (x,y) => x + y;
    exports.sum = (x,y) => x + y;
    <span class="red">exports is a shortcut for module.exports</span>

    on the script using the model:
    require('./math');
    <span class="red">assuming that the module's file is called math.js</span>
</code></pre>

<h3>Requiring a directory</h3>
<p>When requiring an entire folder, node.js will look into index.js, which should be inside that folder.</p>
<p>A common pattern is to require all values into index.js and then export them all from there.</p>

<h2>NPM</h2>
<p>NPM is the largest library of packages, which are modules written by other people, all ready for anyone to use.</p>
<p>NPM is also a command line tool to easily install and manage those packages in our Node projects.</p>

<h3>Installing packages from NPM</h3>
<p>To install a package from NPM, the basic command is: npm install packageName . This command has a shortcut: npm i
    packageName .</p>
<p>The correct packageName can be found in the package's documentation on NPM website.</p>
<p>To globally install a package, just add -g</p>
<pre><code>
    npm i packageName -g 
</code></pre>
<p>The global installation will install the package on the root of the computer, so that every project that requires
    that package will have it available. If the global installation fails, use this line to change permission:</p>
<pre><code>
sudo chown -R $USER/usr/local/lib/node_modules
</code></pre>

<h3>The <i>package.json</i> file</h3>
<p>Before installing any package to a projects folder, we have to run <b>npm init</b>. This will create a package.json
    file in the root of that project. This file contains metadata of the packages used by that project. Everytime we
    install a new package on that folder, this file will automatically update the <b>dependencies</b> property.</p>

<h3>Installing all dependencies for a project</h3>
<p>When uploading a project to GIThub, we don't need to upload the node_modules folder. All we have to do is to upload
    the <i>package.json</i> file. Then, the people who download the project code, will run the command line <i>npm
        install</i> in that folder, and that it! All the dependencies listed on the packages.json file will be
    automatically downloaded for that folder</p>


<h2>Express</h2>
<p>Express.js, or simply Express, is a back end web application framework for Node.js, released as free and open-source
    software under the MIT License. It is designed for building web applications and APIs.[3] It has been called the de
    facto standard server framework for Node.js.</p>

<h3>Starting a server</h3>
<pre><code>
    const express = require('express');
    const app = express();

app.use(() => {
    console.log('WE GOT A NEW REQUEST!');
    res.send('Hello, this is a response'); 
    <span class="red">the send method is what is sent as a response to the browser; it accepts strings, objects (which will be converted to json) and html.</span>
})
<span class="red">app.use is what happens when the request is received</span>

app.listen(8080, () => {
    console.log("LISTENING ON PORT 8080")
})
<span class="red">this sets the port on localhost where the requests are being listened; to access the server, go to localhost:8080 on any browser (on your machine)</span>
</code></pre>

<h3>Express routing basics</h3>
<p>Until now, it doesn't matter if the user is requesting the '/' page or the '/cats' page, with app.use the server will
    always send the same response.</p>
<p>Using app.get, we are able to get the exact request, and respond according to what comes after the /.</p>
<pre><code>
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        res.send('This is the home page!');
    });

    app.get('/cats', (req, res) => {
        res.send('MEOW!');
    });

    app.get('/dogs', (req, res) => {
        res.send('WOOF!');
    });

    app.listen(8080, () => {
        console.log("LISTENING ON PORT 8080")
    })
</code></pre>
<p>Besides 'get', there are other http verbs, like, 'post', 'put', 'delete', etc. Express will differentiate incoming
    request of different types.</p>
<pre><code>
    app.post('/cats', (req, res) => {
        res.send('POST REQUEST TO /cats!!! This is a response!')
    })
</code></pre>
<p>To respond with a customized error page or message to a unexistent request address, (ex: '/hdhebdhbwh'):</p>
<pre><code>
    app.get('*', (req, res) => {
        res.send(`I don't know that path!`);
    });
</code></pre>

<h3>Routing path parameters</h3>
<p>In order to designate a pattern in a route, we can use :</p>
<pre><code>
    <span class="red">for ex, all Reddit's subreddits begin with the pattern /r/something</span>
    app.get('/r/:subreddit', (req, res) => {
        res.send('This is a subreddit!')
    })
</code></pre>
<p><b>req.params</b> is an object that contains one key/value pair for each routed pattern that we defined. The key of
    that property will be the word that we wrote after
    the colon(:), the value of that property will be the actual word requested by the user.</p>
<pre><code>
    app.get('/r/:subreddit', (req, res) => {
        { subredditName } = req.params;
        res.send(`<h1>Browsing the ${subredditName} subreddit!</h1>`)
    })

    app.get('/r/:subreddit/:postId', (req, res) => {
        { subredditName, postId } = req.params;
        res.send(`<h1>Viewing the post called ${postId} on the ${subredditName} subreddit!</h1>`)
    })
</code></pre>

<h3>Query strings</h3>
<p><b>req.query</b> is an object that contains one key/value pair for each query string requested by the user. The key
    of that property will be the name of the html form in which the query is generated, the value of that property will
    be the actual word requested by the user.</p>
<pre><code>
    app.get('search', (req, res) => {
        const { q } = req.query;
        res.send(`<h1>Search results for ${q}</h1>`)
    });
</code></pre>

<h3>Auto-restart server with Nodemon</h3>
<p>Nodemon is a NPM package that automatically restarts the server every time we change our code on that project.
    Otherwise we have to restart the server so that the changes take place.</p>


<h3>Templating</h3>
<p>Templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify.</p>
<p>For example, we could define a single "Search" template that displays all the results for a given search term. We
    don't know what the term is or how many results there are ahead of time. The webpage id created on the fly.</p>
<p>There are many template languages to do this job, for example, EJS (embedded JS), Handlebars, Jade, Pug, Nunjucks
    etc.</p>






<script src="app.js"></script>

</html>